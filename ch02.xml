<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch02">
  <?dbhtml stop-chunking?>

  <title>A Tour of the Dart Language</title>

  <para>This chapter shows you how to use each major Dart feature, from
  variables and operators to classes and libraries, with the assumption that
  you already know how to program in another language.</para>

  <note>
    <para>To play with each feature, create a command-line application project
    in Dart Editor, as described in <xref linkend="ch01-editor" />.</para>
  </note>

  <para>Consult the <ulink url="http://www.dartlang.org/docs/spec/">Dart
  Language Specification</ulink> whenever you want more details about a
  language feature.</para>

  <sect1 id="main-print">
    <title>A Basic Dart Program</title>

    <para>The following code uses many of Dart’s most basic features:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>// Define a function.
printNumber(num aNumber) {
  print('The number is $aNumber.'); // Print to the console.
}

// This is where the app starts executing.
main() {
  var number = 42;           // Declare and initialize a variable.
  printNumber(number);       // Call a function.
}</programlisting>

    <para>Here’s what this program uses that applies to all (or almost all)
    Dart apps:</para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">// <replaceable>This is a
        comment.</replaceable></literal></term>

        <listitem>
          <para>Use // to indicate that the rest of the line is a comment.
          Alternatively, use /* ... */. For details, see <xref
          linkend="comments" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">num</literal></term>

        <listitem>
          <para>A type. Some of the other built-in types are String, int, and
          bool.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">42</literal></term>

        <listitem>
          <para>A number <firstterm>literal</firstterm>. Literals are a kind
          of compile-time constant.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">print()</literal></term>

        <listitem>
          <para>A handy way to display output.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">'...'</literal> (or <literal
        moreinfo="none">"..."</literal>)</term>

        <listitem>
          <para>A string literal.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal
        moreinfo="none">$<replaceable>variableName</replaceable></literal> (or
        <literal
        moreinfo="none">${<replaceable>expression</replaceable></literal><literal
        moreinfo="none">}</literal>)</term>

        <listitem>
          <para>String interpolation: including a variable or expression’s
          string equivalent inside of a string literal. For more information,
          see <xref linkend="strings" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">main()</literal></term>

        <listitem>
          <para>The special, <emphasis>required</emphasis>, top-level function
          where app execution starts.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">var</literal></term>

        <listitem>
          <para>A way to declare a variable without specifying its
          type.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <note>
      <para>Our code follows the conventions in the <ulink
      url="http://www.dartlang.org/articles/style-guide/">Dart Style
      Guide.</ulink> For example, we use two-space indentation.</para>
    </note>
  </sect1>

  <sect1 id="ch02-concepts">
    <title>Important Concepts</title>

    <para>As you learn about the Dart language, keep these facts and concepts
    in mind:</para>

    <itemizedlist>
      <listitem>
        <para>Everything you can place in a variable is an
        <emphasis>object</emphasis>, and every object is an instance of a
        <emphasis>class</emphasis>. Even numbers, functions, and <literal
        moreinfo="none">null</literal> are objects. All objects inherit from
        the <ulink
        url="http://api.dartlang.org/dart_core/Object.html">Object</ulink>
        class.</para>
      </listitem>

      <listitem>
        <para>Specifying static types (such as <literal
        moreinfo="none">num</literal> in the preceding example) clarifies your
        intent and enables static checking by tools, but it’s optional. (You
        might notice when you’re debugging your code that objects with no
        specified type get a special type: <literal
        moreinfo="none">dynamic</literal>.)</para>
      </listitem>

      <listitem>
        <para>Dart parses all your code before running it. You can provide
        tips to Dart—for example, by using types or compile-time constants—to
        catch errors or help your code run faster.</para>
      </listitem>

      <listitem>
        <para>Dart supports top-level functions (such as
        <literal>main()</literal>), as well as functions tied to a class or
        object (<emphasis>static</emphasis> and <emphasis>instance
        methods</emphasis>, respectively). You can also create functions
        within functions (<emphasis>nested</emphasis> or <emphasis>local
        functions</emphasis>).</para>
      </listitem>

      <listitem>
        <para>Similarly, Dart supports top-level
        <emphasis>variables</emphasis>, as well as variables tied to a class
        or object (static and instance variables). Instance variables are
        sometimes known as <firstterm>fields</firstterm> or
        <firstterm>properties</firstterm>.</para>
      </listitem>

      <listitem>
        <para>Unlike Java, Dart doesn’t have the keywords <literal
        moreinfo="none">public</literal>, <literal
        moreinfo="none">protected</literal>, and <literal
        moreinfo="none">private</literal>. If an identifier starts with an
        underscore (_), it’s private to its library. For details, see <xref
        linkend="libraries" />.</para>
      </listitem>

      <listitem>
        <para><firstterm>Identifiers</firstterm> can start with a letter or _,
        followed by any combination of those characters plus digits.</para>
      </listitem>

      <listitem>
        <para>Sometimes it matters whether something is an
        <emphasis>expression</emphasis> or a <emphasis>statement</emphasis>,
        so we’ll be precise about those two words.</para>
      </listitem>

      <listitem>
        <para>Dart tools can report two kinds of errors: warnings and errors.
        Warnings are just hints that your code might not work, but they don’t
        prevent your program from executing. Errors can be either compile-time
        or run-time. A compile-time error prevents the code from executing at
        all; a run-time error results in an <link
        linkend="exceptions">exception</link> being raised while the code
        executes.</para>
      </listitem>

      <listitem>
        <para>Dart has two <firstterm>runtime modes</firstterm>: production
        and checked. Production is faster, but checked is helpful at
        development.</para>
      </listitem>
    </itemizedlist>

    <sect2 id="ch02-keywords">
      <title>Keywords</title>

      <para><xref linkend="keyword_table" /> lists the words that the Dart
      language reserves.</para>

      <para><table class="keywordTable" id="keyword_table">
          <title>Dart keywords</title>

          <tgroup cols="6">
            <tbody>
              <row>
                <entry>abstract</entry>

                <entry>continue</entry>

                <entry>factory</entry>

                <entry>import</entry>

                <entry>return</entry>

                <entry>try</entry>
              </row>

              <row>
                <entry>as</entry>

                <entry>default</entry>

                <entry>false</entry>

                <entry>in</entry>

                <entry>set</entry>

                <entry>typedef</entry>
              </row>

              <row>
                <entry>assert</entry>

                <entry>do</entry>

                <entry>final</entry>

                <entry>is</entry>

                <entry>static</entry>

                <entry>var</entry>
              </row>

              <row>
                <entry>break</entry>

                <entry>dynamic</entry>

                <entry>finally</entry>

                <entry>library</entry>

                <entry>super</entry>

                <entry>void</entry>
              </row>

              <row>
                <entry>case</entry>

                <entry>else</entry>

                <entry>for</entry>

                <entry>new</entry>

                <entry>switch</entry>

                <entry>while</entry>
              </row>

              <row>
                <entry>catch</entry>

                <entry>export</entry>

                <entry>get</entry>

                <entry>null</entry>

                <entry>this</entry>

                <entry>with</entry>
              </row>

              <row>
                <entry>class</entry>

                <entry>external</entry>

                <entry>if</entry>

                <entry>operator</entry>

                <entry>throw</entry>

                <entry></entry>
              </row>

              <row>
                <entry>const</entry>

                <entry>extends</entry>

                <entry>implements</entry>

                <entry>part</entry>

                <entry>true</entry>

                <entry></entry>
              </row>
            </tbody>
          </tgroup>
        </table></para>
    </sect2>

    <sect2 id="ch02-runtime-modes">
      <title>Runtime Modes</title>

      <para>We recommend that you develop and debug in checked mode, and
      deploy to production mode.</para>

      <para><emphasis>Production mode</emphasis> is the default runtime mode
      of a Dart program, optimized for speed. Production mode ignores <link
      linkend="assert">assert statements</link> and static types.</para>

      <para><emphasis>Checked mode</emphasis> is a developer-friendly mode
      that helps you catch some type errors during runtime. For example, if
      you assign a non-number to a variable declared as a <literal
      moreinfo="none">num</literal>, then checked mode throws an
      exception.</para>
    </sect2>
  </sect1>

  <sect1 id="variables">
    <title>Variables</title>

    <para>Here’s an example of creating a variable and assigning a value to
    it:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var name = 'Bob';</programlisting>

    <para>Variables are references. The variable called <literal
    moreinfo="none">name</literal> contains a reference to a String object
    with a value of <quote>Bob</quote>.</para>

    <sect2 id="variables-default-value">
      <title>Default Value</title>

      <para>Uninitialized variables have an initial value of <literal
      moreinfo="none">null</literal>. Even variables with numeric types are
      initially null, because numbers are objects.</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>int lineCount;
assert(lineCount == null); 
// Variables (even if they will be numbers) are initially null.</programlisting>

      <note>
        <para>The <literal>assert()</literal> call is ignored in production
        mode. In checked mode, <literal
        moreinfo="none">assert(<replaceable>condition</replaceable>)</literal>
        throws an exception unless <replaceable>condition</replaceable> is
        true. For details, see <xref linkend="assert" />.</para>
      </note>
    </sect2>

    <sect2 id="variables-optional-types">
      <title>Optional Types</title>

      <para>You have the option of adding static types to your variable
      declarations:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>String name = 'Bob';</programlisting>

      <para>Adding types is a way to clearly express your intent. Tools such
      as compilers and editors can use these types to help you, by providing
      early warnings for bugs and code <phrase
      role="keep-together">completion</phrase>.</para>

      <note>
        <para>This chapter follows the <ulink
        url="http://www.dartlang.org/articles/style-guide/#type-annotations">style
        guide recommendation</ulink> of using <literal
        moreinfo="none">var</literal>, rather than type annotations, for local
        variables.</para>
      </note>
    </sect2>

    <sect2 id="ch02-final-const">
      <title>Final and Const</title>

      <para>If you never intend to change a variable, use <literal
      moreinfo="none">final</literal> or <literal
      moreinfo="none">const</literal>, either instead of <literal
      moreinfo="none">var</literal> or in addition to a type. A final variable
      can be set only once; a const variable is a compile-time
      constant.</para>

      <para>A local, top-level, or class variable that’s declared as <literal
      moreinfo="none">final</literal> is initialized the first time it’s
      used:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>final name = 'Bob';   // Or: final String name = 'Bob';
// name = 'Alice';    // Uncommenting this results in an error</programlisting>

      <note>
        <para>Lazy initialization of final variables helps apps start up
        faster.</para>
      </note>

      <para>Use <literal moreinfo="none">const</literal> for variables that
      you want to be compile-time constants. Where you declare the variable,
      set the value to a compile-time constant such as a literal, a const
      variable, or the result of an arithmetic operation on constant
      numbers:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>const bar = 1000000;       // Unit of pressure (in dynes/cm2)
const atm = 1.01325 * bar; // Standard atmosphere</programlisting>
    </sect2>
  </sect1>

  <sect1 id="built-in-types">
    <title>Built-in Types</title>

    <para>The Dart language has special support for the following
    types:</para>

    <itemizedlist>
      <listitem>
        <para>numbers</para>
      </listitem>

      <listitem>
        <para>strings</para>
      </listitem>

      <listitem>
        <para>booleans</para>
      </listitem>

      <listitem>
        <para>lists (also known as <emphasis>arrays</emphasis>)</para>
      </listitem>

      <listitem>
        <para>maps</para>
      </listitem>
    </itemizedlist>

    <para>You can initialize an object of any of these special types using a
    literal. For example, <literal moreinfo="none">'this is a
    string'</literal> is a string literal, and <literal
    moreinfo="none">true</literal> is a boolean literal.</para>

    <para>Because every variable in Dart refers to an object—an instance of a
    <emphasis>class</emphasis>—you can usually use
    <emphasis>constructors</emphasis> to initialize variables. Some of the
    built-in types have their own constructors. For example, you can use the
    <literal>Map()</literal> constructor to create a map, using code such as
    <literal moreinfo="none">new Map()</literal>.</para>

    <sect2 id="numbers">
      <title>Numbers</title>

      <para>Dart numbers come in two flavors:</para>

      <variablelist>
        <varlistentry>
          <term><ulink url="http://api.dartlang.org/dart_core/int.html">
          <literal moreinfo="none">int</literal> </ulink></term>

          <listitem>
            <para>Integers of arbitrary size</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><ulink url="http://api.dartlang.org/dart_core/double.html">
          <literal moreinfo="none">double</literal> </ulink></term>

          <listitem>
            <para>64-bit (double-precision) floating-point numbers, as
            specified by the IEEE 754 standard</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Both <literal moreinfo="none">int</literal> and <literal
      moreinfo="none">double</literal> are subtypes of <ulink
      url="http://api.dartlang.org/dart_core/num.html"><literal
      moreinfo="none">num</literal>.</ulink> The num type includes basic
      operators such as +, -, /, and *, as well as bitwise operators such as
      &gt;&gt;. The num type is also where you’ll find
      <literal>abs()</literal>,<literal> ceil()</literal>, and
      <literal>floor()</literal>, among other methods. If num and its subtypes
      don’t have what you’re looking for, the <ulink
      url="http://api.dartlang.org/dart_math.html">Math</ulink> library might.
      (In JavaScript produced from Dart code, <ulink
      url="http://dartbug.com/1533">big integers currently behave
      differently</ulink> than they do when the same Dart code runs in the
      Dart VM.)</para>

      <para>Integers are numbers without a decimal point. Here are some
      examples of defining integer literals:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var x = 1;
var hex = 0xDEADBEEF;
var bigInt = 346534658346524376592384765923749587398457294759347029438709349347;</programlisting>

      <para>If a number includes a decimal, it is a double. Here are some
      examples of defining double literals:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var y = 1.1;
var exponents = 1.42e5;</programlisting>

      <para>Here’s how you turn a string into a number, or vice versa:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>// String -&gt; int
var one = int.parse('1');
assert(one == 1);

// String -&gt; double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -&gt; String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -&gt; String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');</programlisting>

      <para>The int type specifies the traditional bitwise shift (&lt;&lt;,
      &gt;&gt;), AND (&amp;), and OR (|) operators. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>assert((3 &lt;&lt; 1) == 6);  // 0011 &lt;&lt; 1 == 0110
assert((3 &gt;&gt; 1) == 1);  // 0011 &gt;&gt; 1 == 0001
assert((3 | 4)  == 7);  // 0011 | 0100 == 0111</programlisting>
    </sect2>

    <sect2 id="strings">
      <title>Strings</title>

      <para>A Dart string is a sequence of UTF-16 code units. You can use
      either single or double quotes to create a string:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to just use the other string delimiter.";</programlisting>

      <para>You can put the value of an expression inside a string by using
      <literal>${</literal><emphasis><literal>expression</literal></emphasis><literal>}</literal>.
      If the expression is an identifier, you can skip the {}. To get the
      string corresponding to an object, Dart calls the object’s
      <literal>toString()</literal> method.</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
       'Dart has string interpolation, which is very handy.');
assert('That deserves all caps. ${s.toUpperCase()} is very handy!' ==
       'That deserves all caps. STRING INTERPOLATION is very handy!');</programlisting>

      <note>
        <para>The <literal moreinfo="none">==</literal> operator tests whether
        two objects are equivalent. Two strings are equivalent if they have
        the same characters.</para>
      </note>

      <para>You can concatenate strings using adjacent string literals:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s = 'String ' 'concatenation'
        " works even over line breaks.";
assert(s == 'String concatenation works even over line breaks.');</programlisting>

      <para>Another way to create a multi-line string: use a triple quote with
      either single or double quotation marks:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";</programlisting>

      <para>You can create a <quote>raw</quote> string by prefixing it with
      <literal moreinfo="none">r</literal>:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var s = r"In a raw string, even \n isn't special.";</programlisting>

      <para>You can use Unicode escapes inside of strings:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/quoting.dart
</remark>print('Unicode escapes work: \u2665'); // Unicode escapes work: [heart]</programlisting>

      <para>For more information on using strings, see <xref
      linkend="ch03-strings-and-regular-expressions" />.</para>
    </sect2>

    <sect2 id="booleans">
      <title>Booleans</title>

      <para>To represent boolean values, Dart has a type named <literal
      moreinfo="none">bool</literal>. Only two objects have type bool: the
      boolean literals, <literal moreinfo="none">true</literal> and <literal
      moreinfo="none">false</literal>.</para>

      <para>When Dart expects a boolean value, only the value <literal
      moreinfo="none">true</literal> is treated as true. All other values are
      treated as false. Unlike in JavaScript, values such as <literal
      moreinfo="none">1</literal>, <literal
      moreinfo="none">"aString"</literal>, and <literal
      moreinfo="none">someObject</literal> are all treated as false.</para>

      <para>For example, consider the following code, which is valid both as
      JavaScript and as Dart code:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var name = 'Bob';
if (name) {
  print('You have a name!'); // Prints in JavaScript, not in Dart.
}</programlisting>

      <para>If you run this code as JavaScript, it prints <quote>You have a
      name!</quote> because <literal moreinfo="none">name</literal> is a
      non-null object. However, in Dart running in <emphasis>production
      mode</emphasis>, the above doesn’t print at all because <literal
      moreinfo="none">name</literal> is converted to <literal
      moreinfo="none">false</literal> (because <literal moreinfo="none">name
      != true</literal>). In Dart running in <emphasis>checked
      mode</emphasis>, the above code throws an exception because the <literal
      moreinfo="none">name</literal> variable is not a bool.</para>

      <para>Here’s another example of code that behaves differently in
      JavaScript and Dart:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (1) {
  print('JavaScript prints this line because it thinks 1 is true.');
} else {
  print('Dart in production mode prints this line.');
  // However, in checked mode, if (1) throws an exception.
}</programlisting>

      <note>
        <para>The previous two samples work only in production mode, not
        checked mode. In checked mode, an exception is thrown if a non-boolean
        is used when a boolean value is expected.</para>
      </note>

      <para>Dart’s treatment of booleans is designed to avoid the strange
      behaviors that can arise when many values can be treated as true. What
      this means for you is that, instead of using code like <literal
      moreinfo="none">if&nbsp;(<replaceable>nonbooleanValue</replaceable>)</literal>,
      you should instead explicitly check for values. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>// Check for an empty string.
var fullName = '';
assert(fullName.isEmpty);

// Check for zero.
var hitPoints = 0;
assert(hitPoints &lt;= 0);

// Check for null.
var unicorn;
assert(unicorn == null);

// Check for NaN.
var iMeantToDoThis = 0/0;
assert(iMeantToDoThis.isNaN);</programlisting>
    </sect2>

    <sect2 id="lists">
      <title>Lists</title>

      <para>Perhaps the most common collection in nearly every programming
      language is the <emphasis>array</emphasis>, or ordered group of objects.
      In Dart, arrays are <ulink
      url="http://api.dartlang.org/dart_core/List.html">List</ulink> objects,
      so we usually just call them <emphasis>lists</emphasis>.</para>

      <para>Dart list literals look like JavaScript array literals. Here’s a
      simple Dart list:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var list = [1,2,3];</programlisting>

      <para>Lists use zero-based indexing, where 0 is the index of the first
      element and <literal moreinfo="none">list.length - 1</literal> is the
      index of the last element. You can get a list’s length and refer to list
      elements just as you would in JavaScript:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var list = [1,2,3];
assert(list.length == 3);
assert(list[1] == 2);</programlisting>

      <para>The List type has many handy methods for manipulating lists. For
      more information about lists, see <xref linkend="generics" /> and <xref
      linkend="ch03-collections" />.</para>
    </sect2>

    <sect2 id="maps">
      <title>Maps</title>

      <para>In general, a map is an object that associates keys and values.
      Dart support for maps is provided by map literals and the <ulink
      url="http://api.dartlang.org/dart_core/Map.html">Map</ulink>
      type.</para>

      <para>Here’s a simple Dart map:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = {                         // A map literal
// Keys       Values
  'first'  : 'partridge',
  'second' : 'turtledoves',
  'fifth'  : 'golden rings'
};</programlisting>

      <para>In map literals, each <emphasis>key</emphasis> must be a string.
      If you use a Map constructor, any object can be a key.</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/map_constructor.dart
</remark>var map = new Map();                  // Use a map constructor.
map[1] = 'partridge';                 // Key is 1; value is 'partridge'.
map[2] = 'turtledoves';               // Key is 2; value is 'turtledoves'.
map[5] = 'golden rings';              // Key is 5; value is 'golden rings'.
</programlisting>

      <para>A map <emphasis>value</emphasis> can be any object, including
      null.</para>

      <para>You add a new key-value pair to an existing map just as you would
      in JavaScript:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';    // Add a key-value pair</programlisting>

      <para>You retrieve a value from a map the same way you would in
      JavaScript:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
assert(gifts['first'] == 'partridge');</programlisting>

      <para>If you look for a key that isn’t in a map, you get a null in
      return:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
assert(gifts['fifth'] == null);</programlisting>

      <para>Use <literal moreinfo="none">.length</literal> to get the number
      of key-value pairs in the map:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var gifts = { 'first': 'partridge' };
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);</programlisting>

      <para>For more information about maps, see <xref linkend="generics" />
      and <xref linkend="ch03-maps-aka-dictionaries-or-hashes" />.</para>
    </sect2>
  </sect1>

  <sect1 id="functions">
    <title>Functions</title>

    <para>Here’s an example of implementing a function:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>void printNumber(num number) {
  print('The number is $number.');
}</programlisting>

    <para>Although the style guide recommends specifying the parameter and
    return types, you don’t have to:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(number) {          // Omitting types is OK.
  print('The number is $number.');
}</programlisting>

    <para>For functions that contain just one expression, you can use a
    shorthand syntax:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(number) =&gt; print('The number is $number.');</programlisting>

    <para>The <literal moreinfo="none">=&gt;
    <replaceable>expr</replaceable>;</literal> syntax is a shorthand for
    <literal moreinfo="none">{ return
    <replaceable>expr</replaceable>;}</literal>. In the
    <literal>printNumber()</literal> function above, the expression is the
    call to the top-level <literal>print()</literal> function.</para>

    <note>
      <para>Only an <emphasis>expression</emphasis>—not a
      <emphasis>statement</emphasis>—can appear between the <phrase
      role="keep-together">arrow (=&gt;)</phrase> and the semicolon (;). For
      example, you can’t put an <link linkend="if-else"><phrase
      role="keep-together">if statement</phrase></link> there, but you can use
      a <link linkend="op-other">conditional (<literal>?:</literal>)
      expression</link>.</para>
    </note>

    <para>You can use types with =&gt;, although the convention is not to do
    so:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(num number) =&gt; print('The number is $number.'); // Types are OK.</programlisting>

    <para>Here’s an example of calling a function:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>printNumber(123);</programlisting>

    <para>A function can have two types of parameters: required and optional.
    The required parameters are listed first, followed by any optional
    parameters.</para>

    <sect2 id="functions-optional-parameters">
      <title>Optional Parameters</title>

      <para>Optional parameters can be either positional or named, but not
      both.</para>

      <para>Both kinds of optional parameter can have default values. The
      default values must be compile-time constants such as literals. If no
      default value is provided, the value is <literal
      moreinfo="none">null</literal>.</para>

      <sect3 id="functions-optional-named-parameters">
        <title>Optional named parameters</title>

        <para>When calling a function, you can specify named parameters using
        <literal moreinfo="none"><replaceable>paramName</replaceable>:
        <replaceable>value</replaceable></literal>. For example:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>enableFlags(bold: true, hidden: false);</programlisting>

        <para>When defining a function, use <literal
        moreinfo="none">{<replaceable>param1</replaceable>,
        <replaceable>param2</replaceable>, …}</literal> to specify named
        parameters:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>/// Sets the [bold] and [hidden] flags to the values you specify.
enableFlags({bool bold, bool hidden}) {
  // ...
}</programlisting>

        <para>Use a colon (<literal moreinfo="none">:</literal>) to specify
        default values:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>/**
 * Sets the [bold] and [hidden] flags to the values you specify,
 * defaulting to false.
 */
enableFlags({bool bold: false, bool hidden: false}) {
  // ...
}

enableFlags(bold: true); // bold will be true; hidden will be false.</programlisting>
      </sect3>

      <sect3 id="functions-optional-positional-parameters">
        <title>Optional positional parameters</title>

        <para>Wrapping a set of function parameters in <literal
        moreinfo="none">[]</literal> marks them as optional positional <phrase
        role="keep-together">parameters</phrase>:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>String say(String from, String msg, [String device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}</programlisting>

        <para>Here’s an example of calling this function without the optional
        parameter:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>assert(say('Bob', 'Howdy') == 'Bob says Howdy');</programlisting>

        <para>And here’s an example of calling this function with the third
        parameter:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>assert(say('Bob', 'Howdy', 'smoke signal') ==
  'Bob says Howdy with a smoke signal');</programlisting>

        <para>Use <literal moreinfo="none">=</literal> to specify default
        values:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark>String say(String from, String msg,
  [String device='carrier pigeon', String mood]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  if (mood != null) {
    result = '$result (in a $mood mood)';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');</programlisting>
      </sect3>
    </sect2>

    <sect2 id="ch02-functions-first-class">
      <title>Functions as First-Class Objects</title>

      <para>You can pass a function as a parameter to another function. For
      example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>printElement(element) {
  print(element);
}
  
var list = [1,2,3];
list.forEach(printElement); // Pass printElement as a parameter.</programlisting>

      <para>You can also assign a function to a variable, such as:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var loudify = (msg) =&gt; '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');</programlisting>
    </sect2>

    <sect2 id="ch02-lexical-scope">
      <title>Lexical Scope</title>

      <para>Dart is a lexically scoped language, which means that the scope of
      variables is determined statically, simply by the layout of the code.
      You can “follow the curly braces outwards” to see if a variable is in
      scope.</para>

      <para>Here is an example of nested functions with variables at each
      scope level:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var topLevel = true;
main() {
    var insideMain = true;
    
    myFunction() {
      var insideFunction = true;
      
      nestedFunction() {
        var insideNestedFunction = true;
        assert(topLevel);
        assert(insideMain);
        assert(insideFunction);
        assert(insideNestedFunction);
      }
    }
}</programlisting>

      <para>Notice how <literal>nestedFunction()</literal> can use variables
      from every level, all the way up to the top level.</para>
    </sect2>

    <sect2 id="ch02-functions-lexical-closures">
      <title>Lexical Closures</title>

      <para>A <emphasis>closure</emphasis> is a function object that has
      access to variables in its lexical scope, even when the function is used
      outside of its original scope.</para>

      <para>Functions can close over variables defined in surrounding scopes.
      In the following example, <literal>adder()</literal> captures the
      variable <literal moreinfo="none">addBy</literal>. Wherever the returned
      function goes, it remembers <literal
      moreinfo="none">addBy</literal>.</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/function_closure.dart
</remark>/// Returns a function that adds [addBy] to a number.
Function makeAdder(num addBy) {
  adder(num i) {
    return addBy + i;
  }
  return adder;
}

main() {
  var add2 = makeAdder(2); // Create a function that adds 2.
  var add4 = makeAdder(4); // Create a function that adds 4.

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}</programlisting>
    </sect2>

    <sect2 id="ch02-function-equality">
      <title>Testing for Equality</title>

      <para>Each time you create a closure, that closure is a new object. This
      can cause problems when you want to test whether two functions are
      equivalent. For example, consider this code:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/function_equality.dart
</remark>var s = 'some string';       // Create a String object.
var splitClosure1 = s.split; // Get a reference to its split() method.
var splitClosure2 = s.split; // Get another reference to its split() method.

// Because each reference to the method creates a separate closure,
// s.split != s.split, and splitClosure1 != splitClosure2.
assert(s.split != s.split);
assert(splitClosure1 != splitClosure2);
</programlisting>

      <para>The key to comparing instance methods is to save a reference to
      the closure:</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/function_equality.dart
</remark>splitClosure2 = splitClosure1;
assert(splitClosure1 == splitClosure2);</programlisting>

      <para>Top-level and static methods are different—you can compare them by
      name:</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/function_equality_2.dart
</remark>foo() {}

class SomeClass {
  static void bar() {}
}

main() {
  assert(foo == foo);
  assert(SomeClass.bar == SomeClass.bar);
}</programlisting>
    </sect2>

    <sect2 id="ch02-functions-return-values">
      <title>Return Values</title>

      <para>All functions return a value. If no return value is specified, the
      statement <literal moreinfo="none">return null;</literal> is implicitly
      appended to the function body.</para>
    </sect2>
  </sect1>

  <sect1 id="operators">
    <title>Operators</title>

    <para>Dart defines the operators shown in <xref
    linkend="operator_table" />. You can override many of these operators, as
    described in <xref linkend="classes-operators" />.</para>

    <table class="operatorTable" id="operator_table">
      <title>Operators and their precedence</title>

      <tgroup cols="2">
        <thead>
          <row>
            <entry>Description</entry>

            <entry>Operator</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>unary postfix</entry>

            <entry class="operatorList"><replaceable>expr</replaceable>++
            &nbsp;&nbsp; <replaceable>expr</replaceable>-- &nbsp;&nbsp; ()
            &nbsp;&nbsp; [] &nbsp;&nbsp; .</entry>
          </row>

          <row>
            <entry>unary prefix</entry>

            <entry class="operatorList">-<replaceable>expr</replaceable>
            &nbsp;&nbsp; !<replaceable>expr</replaceable> &nbsp;&nbsp;
            ~<replaceable>expr</replaceable> &nbsp;&nbsp;
            ++<replaceable>expr</replaceable> &nbsp;&nbsp;
            --<replaceable>expr</replaceable> &nbsp;&nbsp;</entry>
          </row>

          <row>
            <entry>multiplicative</entry>

            <entry class="operatorList">* &nbsp;&nbsp; / &nbsp;&nbsp; %
            &nbsp;&nbsp; ~/</entry>
          </row>

          <row>
            <entry>additive</entry>

            <entry class="operatorList">+ &nbsp;&nbsp; -</entry>
          </row>

          <row>
            <entry>shift</entry>

            <entry class="operatorList">&lt;&lt; &nbsp;&nbsp; &gt;&gt;</entry>
          </row>

          <row>
            <entry>relational and type test</entry>

            <entry class="operatorList">&gt;= &nbsp;&nbsp; &gt; &nbsp;&nbsp;
            &lt;= &nbsp;&nbsp; &lt; &nbsp;&nbsp; as &nbsp;&nbsp; is
            &nbsp;&nbsp; is!</entry>
          </row>

          <row>
            <entry>equality</entry>

            <entry class="operatorList">== &nbsp;&nbsp; !=
            &nbsp;&nbsp;</entry>
          </row>

          <row>
            <entry>bitwise AND</entry>

            <entry class="operatorList">&amp;</entry>
          </row>

          <row>
            <entry>bitwise XOR</entry>

            <entry class="operatorList">^</entry>
          </row>

          <row>
            <entry>bitwise OR</entry>

            <entry class="operatorList">|</entry>
          </row>

          <row>
            <entry>logical AND</entry>

            <entry class="operatorList">&amp;&amp;</entry>
          </row>

          <row>
            <entry>logical OR</entry>

            <entry class="operatorList">||</entry>
          </row>

          <row>
            <entry>conditional</entry>

            <entry class="operatorList"><replaceable>expr1</replaceable> ?
            <replaceable>expr2</replaceable> :
            <replaceable>expr3</replaceable></entry>
          </row>

          <row>
            <entry>cascade</entry>

            <entry class="operatorList">..</entry>
          </row>

          <row>
            <entry>assignment</entry>

            <entry class="operatorList">= &nbsp;&nbsp; *= &nbsp;&nbsp; /=
            &nbsp;&nbsp; ~/= &nbsp;&nbsp; %= &nbsp;&nbsp; += &nbsp;&nbsp; -=
            &nbsp;&nbsp; &lt;&lt;= &nbsp;&nbsp; &gt;&gt;= &nbsp;&nbsp; &amp;=
            &nbsp;&nbsp; ^= &nbsp;&nbsp; |= &nbsp;&nbsp;</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>When you use operators, you create
    <firstterm>expressions</firstterm>. Here are some examples of operator
    expressions:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>a++
a + b
a = b
a == b
a? b: c
a is T</programlisting>

    <para>In <xref linkend="operator_table" />, each operator has higher
    precedence than the operators in the rows below it. For example, the
    multiplicative operator <literal moreinfo="none">%</literal> has higher
    precedence than (and thus executes before) the equality operator <literal
    moreinfo="none">==</literal>, which has higher precedence than the logical
    AND operator <literal moreinfo="none">&amp;&amp;</literal>. That
    precedence means that the following two lines of code execute the same
    way:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>if ((n % i == 0) &amp;&amp; (d % i == 0)) // Parens improve readability.
if (n % i == 0 &amp;&amp; d % i == 0)     // Harder to read, but equivalent.</programlisting>

    <warning>
      <para>For operators that work on two operands, the leftmost operand
      determines which version of the operator is used. For example, if you
      have a Vector object and a Point object, <literal
      moreinfo="none">aVector + aPoint</literal> uses the Vector version of
      +.</para>
    </warning>

    <sect2 id="op-arithmetic">
      <title>Arithmetic Operators</title>

      <para>Dart supports the usual arithmetic operators, as shown in <xref
      linkend="arithmetic_operator_table" />.</para>

      <table class="operatorTable" id="arithmetic_operator_table"
             role="keep-together">
        <title>Arithmetic operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">+</entry>

              <entry>Add</entry>
            </row>

            <row>
              <entry class="operator">–</entry>

              <entry>Subtract</entry>
            </row>

            <row>
              <entry class="operator">-<replaceable>expr</replaceable></entry>

              <entry>Unary minus, also known as negation (reverse the sign of
              the expression)</entry>
            </row>

            <row>
              <entry class="operator">*</entry>

              <entry>Multiply</entry>
            </row>

            <row>
              <entry class="operator">/</entry>

              <entry>Divide</entry>
            </row>

            <row>
              <entry class="operator">~/</entry>

              <entry>Divide, returning an integer result</entry>
            </row>

            <row>
              <entry class="operator">%</entry>

              <entry>Get the remainder of an integer division (modulo)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Example:</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/arithmetic_operators.dart
</remark>assert(2 + 3 == 5);
assert(2 - 3 == -1);
assert(2 * 3 == 6);
assert(5 / 2 == 2.5);   // Result is a double
assert(5 ~/ 2 == 2);    // Result is an integer
assert(5 % 2 == 1);     // Remainder

print('5/2 = ${5~/2} remainder ${5%2}'); // 5/2 = 2 remainder 1</programlisting>

      <para>Dart also supports both prefix and postfix increment and decrement
      operators.</para>

      <table class="operatorTable" id="pfix_operator_table">
        <title>Increment and decrement operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">++<replaceable>var</replaceable></entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> + 1 (expression value is
              <replaceable>var</replaceable> + 1)</entry>
            </row>

            <row>
              <entry class="operator"><replaceable>var</replaceable>++</entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> + 1 (expression value is
              <replaceable>var</replaceable>)</entry>
            </row>

            <row>
              <entry class="operator">--<replaceable>var</replaceable></entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> – 1 (expression value is
              <replaceable>var</replaceable> – 1)</entry>
            </row>

            <row>
              <entry class="operator"><replaceable>var</replaceable>--</entry>

              <entry><replaceable>var</replaceable> =
              <replaceable>var</replaceable> – 1 (expression value is
              <replaceable>var</replaceable>)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var a, b;

a = 0;  
b = ++a;         // Increment a before b gets its value.
assert(a == b);  // 1 == 1  

a = 0;
b = a++;         // Increment a AFTER b gets its value.
assert(a != b);  // 1 != 0

a = 0;
b = --a;         // Decrement a before b gets its value.
assert(a == b);  // -1 == -1

a = 0;
b = a--;         // Decrement a AFTER b gets its value.
assert(a != b) ; // -1 != 0</programlisting>
    </sect2>

    <sect2 id="op-equality">
      <title>Equality and Relational Operators</title>

      <table class="operatorTable" id="equality_operator_table">
        <title>Equality and relational operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">==</entry>

              <entry>Equal; see discussion below</entry>
            </row>

            <row>
              <entry class="operator">!=</entry>

              <entry>Not equal</entry>
            </row>

            <row>
              <entry class="operator">&gt;</entry>

              <entry>Greater than</entry>
            </row>

            <row>
              <entry class="operator">&lt;</entry>

              <entry>Less than</entry>
            </row>

            <row>
              <entry class="operator">&gt;=</entry>

              <entry>Greater than or equal to</entry>
            </row>

            <row>
              <entry class="operator">&lt;=</entry>

              <entry>Less than or equal to</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>To test whether two objects <replaceable>x</replaceable> and
      <replaceable>y</replaceable> represent the same thing, use the <literal
      moreinfo="none">==</literal> operator. (In the rare case where you need
      to know whether two objects are the exact same object, use the
      <literal><ulink
      url="http://api.dartlang.org/dart_core.html#identical">identical()</ulink></literal>
      function instead.) Here’s how the <literal moreinfo="none">==</literal>
      operator works:</para>

      <orderedlist continuation="restarts" inheritnum="ignore">
        <listitem>
          <para>If <replaceable>x</replaceable> or
          <replaceable>y</replaceable> is null, return true if both are null,
          and false if only one is null.</para>
        </listitem>

        <listitem>
          <para>Return the result of the method invocation <literal
          moreinfo="none"><replaceable>x</replaceable>.==(<replaceable>y</replaceable>)</literal>.
          (That’s right, operators such as <literal
          moreinfo="none">==</literal> are methods that are invoked on their
          first operand. You can even override many operators, including
          <literal>==</literal>, as you’ll see in <xref
          linkend="classes-operators" />.)</para>
        </listitem>
      </orderedlist>

      <para>Here’s an example of using each of the equality and relational
      operators:</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/op_equality.dart
</remark>assert(2 == 2);
assert(2 != 3);
assert(3 &gt; 2);
assert(2 &lt; 3);
assert(3 &gt;= 3);
assert(2 &lt;= 3);</programlisting>
    </sect2>

    <sect2 id="ch02-op-type-test">
      <title>Type Test Operators</title>

      <para>The <literal moreinfo="none">as</literal>, <literal
      moreinfo="none">is</literal>, and <literal moreinfo="none">is!</literal>
      operators are handy for checking types at runtime.</para>

      <table class="typeTestTable" id="type_test_operator_table">
        <title>Type test operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>as</entry>

              <entry>Typecast</entry>
            </row>

            <row>
              <entry class="operator">is</entry>

              <entry>True if the object has the specified type</entry>
            </row>

            <row>
              <entry class="operator">is!</entry>

              <entry>False if the object has the specified type</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The result of <literal moreinfo="none">obj is T</literal> is true
      if <literal moreinfo="none">obj</literal> implements the interface
      specified by <literal moreinfo="none">T</literal>. For example, <literal
      moreinfo="none">obj is Object</literal> is always true.</para>

      <para>Use the <literal moreinfo="none">as</literal> operator to cast an
      object to a particular type. In general, you should use it as a
      shorthand for an <literal moreinfo="none">is</literal> test on an object
      following by an expression using that object. For example, consider the
      following code:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (person is Person) {               // Type check
  person.firstName = 'Bob';
}</programlisting>

      <para>You can make the code shorter using the <literal
      moreinfo="none">as</literal> operator:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>(person as Person).firstName = 'Bob';</programlisting>

      <note>
        <para>The code isn’t equivalent. If <literal>person</literal> is null
        or not a Person, the first example (with <literal>is</literal>) does
        nothing; the second (with <literal>as</literal>) throws an <phrase
        role="keep-together">exception</phrase>.</para>
      </note>
    </sect2>

    <sect2 id="op-assign">
      <title>Assignment Operators</title>

      <para>As you’ve already seen, you assign values using the <literal
      moreinfo="none">=</literal> operator. You can also use compound
      assignment operators such as <literal moreinfo="none">+=</literal>,
      which combine an operation with an <phrase
      role="keep-together">assignment</phrase>.</para>

      <table id="assignment_operator_table" role="keep-together">
        <title>Assignment operators</title>

        <tgroup cols="6">
          <tbody>
            <row>
              <entry>=</entry>

              <entry>–=</entry>

              <entry>/=</entry>

              <entry>%=</entry>

              <entry>&gt;&gt;=</entry>

              <entry>^=</entry>
            </row>

            <row>
              <entry>+=</entry>

              <entry>*=</entry>

              <entry>~/=</entry>

              <entry>&lt;&lt;=</entry>

              <entry>&amp;=</entry>

              <entry>|=</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Here’s how compound assignment operators work:</para>

      <informaltable id="assignment_operator_concepts_table">
        <tgroup cols="3">
          <thead>
            <row>
              <entry></entry>

              <entry>Compound assignment</entry>

              <entry>Equivalent expression</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><emphasis role="bold">For an operator
              <replaceable>op</replaceable>:</emphasis></entry>

              <entry><literal moreinfo="none">a <replaceable>op</replaceable>=
              b</literal></entry>

              <entry><literal moreinfo="none">a = a
              <replaceable>op</replaceable> b</literal></entry>
            </row>

            <row>
              <entry><emphasis role="bold">Example: </emphasis></entry>

              <entry><literal moreinfo="none">a += b</literal></entry>

              <entry><literal moreinfo="none">a = a + b</literal></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The following example uses both assignment and compound assignment
      operators:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var a = 2;           // Assign using =
a *= 3;              // Assign and multiply: a = a * 3
assert(a == 6);</programlisting>
    </sect2>

    <sect2 id="op-logical">
      <title>Logical Operators</title>

      <para>You can invert or combine boolean expressions using the logical
      operators.</para>

      <table class="operatorTable" id="logical_operator_table"
             role="keep-together">
        <title>Logical operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">!<replaceable>expr</replaceable></entry>

              <entry>inverts the following expression (changes false to true,
              and vice versa)</entry>
            </row>

            <row>
              <entry class="operator">||</entry>

              <entry>logical OR</entry>
            </row>

            <row>
              <entry class="operator">&amp;&amp;</entry>

              <entry>logical AND</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Here’s an example of using the logical operators:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (!done &amp;&amp; (col == 0 || col == 3)) {
  // ...Do something...
}</programlisting>
    </sect2>

    <sect2 id="op-bit">
      <title>Bitwise and Shift Operators</title>

      <para>You can manipulate the individual bits of numbers in Dart.
      Usually, you’d use these bitwise and shift operators with integers, as
      shown in <xref linkend="bit_operator_table" />.</para>

      <table class="operatorTable" id="bit_operator_table">
        <title>Bitwise and shift operators</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Operator</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">&amp;</entry>

              <entry>AND</entry>
            </row>

            <row>
              <entry class="operator">|</entry>

              <entry>OR</entry>
            </row>

            <row>
              <entry class="operator">^</entry>

              <entry>XOR</entry>
            </row>

            <row>
              <entry class="operator">~<replaceable>expr</replaceable></entry>

              <entry>Unary bitwise complement (0s become 1s; 1s become
              0s)</entry>
            </row>

            <row>
              <entry class="operator">&lt;&lt;</entry>

              <entry>Shift left</entry>
            </row>

            <row>
              <entry class="operator">&gt;&gt;</entry>

              <entry>Shift right</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Here’s an example of using bitwise and shift operators:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>final value = 0x22;
final bitmask = 0x0f;

assert((value &amp; bitmask)  == 0x02);  // AND
assert((value &amp; ~bitmask) == 0x20);  // AND NOT
assert((value | bitmask)  == 0x2f);  // OR
assert((value ^ bitmask)  == 0x2d);  // XOR
assert((value &lt;&lt; 4)       == 0x220); // Shift left
assert((value &gt;&gt; 4)       == 0x02);  // Shift right</programlisting>
    </sect2>

    <sect2 id="op-other">
      <title>Other Operators</title>

      <para>A few operators remain, most of which you’ve already seen in other
      examples.</para>

      <table class="operatorTable" id="other_operator_table"
             role="keep-together">
        <title>Other operators</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry style="text-align:center">Operator</entry>

              <entry>Name</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry class="operator">()</entry>

              <entry>Function application</entry>

              <entry>Represents a function call</entry>
            </row>

            <row>
              <entry class="operator">[]</entry>

              <entry>List access</entry>

              <entry>Refers to the value at the specified index in the
              list</entry>
            </row>

            <row>
              <entry
              class="operator"><replaceable>expr1</replaceable>&nbsp;?&nbsp;<replaceable>expr2</replaceable>&nbsp;:&nbsp;<replaceable>expr3</replaceable></entry>

              <entry>Conditional</entry>

              <entry>If <replaceable>expr1</replaceable> is true, executes
              <replaceable>expr2</replaceable>; otherwise, executes
              <replaceable>expr3</replaceable></entry>
            </row>

            <row>
              <entry class="operator">.</entry>

              <entry>Member access</entry>

              <entry>Refers to a property of an expression; example: <literal
              moreinfo="none">foo.bar</literal> selects property <literal
              moreinfo="none">bar</literal> from expression <literal
              moreinfo="none">foo</literal></entry>
            </row>

            <row>
              <entry class="operator">..</entry>

              <entry>Cascade</entry>

              <entry class="operator">Allows you to perform multiple
              operations on the members of a single object; described in <xref
              linkend="classes" /></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>
  </sect1>

  <sect1 id="control-flow-statements">
    <title>Control Flow Statements</title>

    <para>You can control the flow of your Dart code using any of the
    following:</para>

    <itemizedlist>
      <listitem>
        <para><literal moreinfo="none">if</literal> and <literal
        moreinfo="none">else</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">for</literal> loops</para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">while</literal> and <literal
        moreinfo="none">do</literal>-<literal moreinfo="none">while</literal>
        loops</para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">break</literal> and <literal
        moreinfo="none">continue</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">switch</literal> and <literal
        moreinfo="none">case</literal></para>
      </listitem>

      <listitem>
        <para><literal moreinfo="none">assert</literal></para>
      </listitem>
    </itemizedlist>

    <para>You can also affect the control flow using <literal
    moreinfo="none">try-catch</literal> and <literal
    moreinfo="none">throw</literal>, as explained in <xref
    linkend="exceptions" />.</para>

    <sect2 id="if-else">
      <title>If and Else</title>

      <para>Dart supports <literal moreinfo="none">if</literal> statements
      with optional <literal moreinfo="none">else</literal> statements, as the
      next sample shows. Also see conditional expressions (?:), which are
      covered in <xref linkend="op-other" />.</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}</programlisting>

      <para>Remember, unlike JavaScript, Dart treats all values other than
      <literal moreinfo="none">true</literal> as <literal
      moreinfo="none">false</literal>. See <xref linkend="booleans" /> for
      more information.</para>
    </sect2>

    <sect2 id="for-loops">
      <title>For Loops</title>

      <para>You can iterate with the standard <literal
      moreinfo="none">for</literal> loop. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var message = new StringBuffer("Dart is fun");
for (var i = 0; i &lt; 5; i++) {
  message.write('!');
}</programlisting>

      <para>Closures inside of Dart’s <literal moreinfo="none">for</literal>
      loops capture the value of the index, avoiding a common pitfall found in
      JavaScript. For example, consider:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var callbacks = [];
for (var i = 0; i &lt; 2; i++) {
  callbacks.add(() =&gt; print(i));
}
callbacks.forEach((c) =&gt; c());</programlisting>

      <para>The output is <literal moreinfo="none">0</literal> and then
      <literal moreinfo="none">1</literal>, as expected. In contrast, the
      example would print <literal moreinfo="none">2</literal> and then
      <literal moreinfo="none">2</literal> in JavaScript.</para>

      <para>If the object that you are iterating over is an Iterable, you can
      use the <literal><ulink
      url="http://api.dartlang.org/dart_core/Iterable.html#forEach">forEach()</ulink></literal>
      method. Using <literal>forEach()</literal> is a good option if you don’t
      need to know the current iteration counter:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>candidates.forEach((candidate) =&gt; candidate.interview());</programlisting>

      <para>Iterable classes such as List and Set also support the <literal
      moreinfo="none">for-in</literal> form of iteration, which is described
      <phrase lang="" role="">in <xref
      linkend="ch03-iteration" />:</phrase></para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/flow_for_loops.dart
</remark>var collection = [0, 1, 2];
for (var x in collection) {
  print(x);
}</programlisting>
    </sect2>

    <sect2 id="while">
      <title>While and Do-While</title>

      <para>A <literal moreinfo="none">while</literal> loop evaluates the
      condition before the loop:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>while(!isDone()) {
  doSomething();
}</programlisting>

      <para>A <literal moreinfo="none">do</literal>-<literal
      moreinfo="none">while</literal> loop evaluates the condition
      <emphasis>after</emphasis> the loop:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>do {
  printLine();
} while (!atEndOfPage());</programlisting>
    </sect2>

    <sect2 id="break">
      <title>Break and Continue</title>

      <para>Use <literal moreinfo="none">break</literal> to stop
      looping:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}</programlisting>

      <para>Use <literal moreinfo="none">continue</literal> to skip to the
      next loop iteration:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>for (int i = 0; i &lt; candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience &lt; 5) {
    continue;
  }
  candidate.interview();
}</programlisting>

      <para>You might write that example differently if you’re using a <ulink
      url="http://api.dartlang.org/dart_core/Iterable.html">Iterable</ulink>
      such as a list or set:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>candidates.where((c) =&gt; c.yearsExperience &gt;= 5)
          .forEach((c) =&gt; c.interview());</programlisting>
    </sect2>

    <sect2 id="switch">
      <title>Switch and Case</title>

      <para>Switch statements in Dart compare integer, string, or compile-time
      constants using <literal moreinfo="none">==</literal>. The compared
      objects must all be instances of the same class (and not of any of its
      subtypes), and the class must not override <literal
      moreinfo="none">==</literal>.</para>

      <para>Each non-empty <literal moreinfo="none">case</literal> clause ends
      with a <literal moreinfo="none">break</literal> statement, as a rule.
      Other valid ways to end a non-empty <literal
      moreinfo="none">case</literal> clause are a <literal
      moreinfo="none">continue</literal>, <literal
      moreinfo="none">throw</literal>, or <literal
      moreinfo="none">return</literal> statement.</para>

      <para>Use a <literal moreinfo="none">default</literal> clause to execute
      code when no <literal moreinfo="none">case</literal> clause
      matches:</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
    break;
  case 'PENDING':
    executePending();
    break;
  case 'APPROVED':
    executeApproved();
    break;
  case 'DENIED':
    executeDenied();
    break;
  case 'OPEN':
    executeOpen();
    break;
  default:
    executeUnknown();
}</programlisting>

      <para>The following example omits the <literal
      moreinfo="none">break</literal> statement in the <literal
      moreinfo="none">case</literal> clause, thus generating an error:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var command = 'OPEN';
switch (command) {
  case 'OPEN':
    executeOpen();
    // ERROR: Missing break causes an exception to be thrown!!

  case 'CLOSED':
    executeClosed();
    break;
}</programlisting>

      <para>However, Dart does support empty <literal
      moreinfo="none">case</literal> clauses, allowing a form of
      fall-through:</para>

      <programlisting format="linespecific" role=""><remark>lang-dart
</remark>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':     // Empty case falls through.
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}</programlisting>

      <para>If you really want fall-through, you can use a <literal
      moreinfo="none">continue</literal> statement and a label:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed; // Continues executing at the nowClosed label.

nowClosed:
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}</programlisting>

      <para>A <literal moreinfo="none">case</literal> clause can have local
      variables, which are visible only inside the scope of that
      clause.</para>
    </sect2>

    <sect2 id="assert">
      <title>Assert</title>

      <para>Use an <literal moreinfo="none">assert</literal> statement to
      disrupt normal execution if a boolean condition is false. You can find
      examples of assert statements throughout this tour. Here are some
      more:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>assert(text != null);  // Make sure the variable has a non-null value.
assert(number &lt; 100);  // Make sure the value is less than 100.
assert(urlString.startsWith('https')); // Make sure this is an HTTPS URL.</programlisting>

      <note>
        <para>Assert statements work only in checked mode. They have no effect
        in production mode.</para>
      </note>

      <para>Inside the parentheses after <literal
      moreinfo="none">assert</literal>, you can put any expression that
      resolves to a boolean value or to a function. If the expression’s value
      or function’s return value is true, the assertion succeeds and execution
      continues. Otherwise, the assertion fails and an exception (an <ulink
      url="http://api.dartlang.org/dart_core/AssertionError.html">AssertionError</ulink>)
      is thrown.</para>
    </sect2>
  </sect1>

  <sect1 id="exceptions">
    <title>Exceptions</title>

    <para>Your Dart code can throw and catch exceptions. Exceptions are errors
    indicating that something unexpected happened. If the exception isn’t
    caught, the isolate that raised the exception is suspended, and typically
    the isolate and its program are terminated.</para>

    <para>In contrast to Java, all of Dart’s exceptions are unchecked
    exceptions. Methods do not declare which exceptions they might throw, and
    you are not required to catch any <phrase
    role="keep-together">exceptions</phrase>.</para>

    <para>Dart provides <ulink
    url="http://api.dartlang.org/dart_core/Exception.html">Exception</ulink>
    and <ulink
    url="http://api.dartlang.org/docs/continuous/dart_core/Error.html">Error</ulink>
    types, as well as numerous predefined subtypes. You can, of course, define
    your own exceptions. However, Dart programs can throw any non-null
    object—not just Exception and Error objects—as an exception.</para>

    <sect2 id="ch02-exceptions-throw">
      <title>Throw</title>

      <para>Here’s an example of throwing, or <emphasis>raising</emphasis>, an
      exception:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>throw new ExpectException('Value must be greater than zero');</programlisting>

      <para>You can also throw arbitrary objects:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>throw 'Out of llamas!';</programlisting>

      <para>Because throwing an exception is an expression, you can throw
      exceptions in =&gt; statements, as well as anywhere else that allows
      expressions:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>distanceTo(Point other) =&gt; throw new UnimplementedError();</programlisting>
    </sect2>

    <sect2 id="ch02-exceptions-catch">
      <title>Catch</title>

      <para>Catching, or capturing, an exception stops the exception from
      propagating. Catching an exception gives you a chance to handle
      it:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}</programlisting>

      <para>To handle code that can throw more than one type of exception, you
      can specify multiple catch clauses. The first catch clause that matches
      the thrown object’s type handles the exception. If the catch clause does
      not specify a type, that clause can handle any type of thrown
      object:</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} on OutOfLlamasException {           // A specific exception
  buyMoreLlamas();
} on Exception catch(e) {             // Anything else that is an exception
  print('Unknown exception: $e');
} catch(e) {                          // No specified type, handles all
  print('Something really unknown: $e');
}</programlisting>

      <para>As the preceding code shows, you can use either <literal
      moreinfo="none">on</literal> or <literal moreinfo="none">catch</literal>
      or both. Use <literal moreinfo="none">on</literal> when you need to
      specify the exception type. Use <literal moreinfo="none">catch</literal>
      when your exception handler needs the exception object.</para>
    </sect2>

    <sect2 id="ch02-exceptions-finally">
      <title>Finally</title>

      <para>To ensure that some code runs whether or not an exception is
      thrown, use a <literal moreinfo="none">finally</literal> clause. If no
      <literal>catch</literal> clause matches the exception, the exception is
      propagated after the <literal>finally</literal> clause runs:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} finally {
  cleanLlamaStalls();  // Always clean up, even if an exception is thrown.
}</programlisting>

      <para>The <literal>finally</literal> clause runs after any matching
      <literal>catch</literal> clauses:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>try {
  breedMoreLlamas();
} catch(e) {
  print('Error: $e');  // Handle the exception first.
} finally {
  cleanLlamaStalls();  // Then clean up.
}</programlisting>

      <para>Learn more by reading <xref linkend="ch03-exceptions" />.</para>
    </sect2>
  </sect1>

  <sect1 id="classes">
    <title>Classes</title>

    <para>Dart is an object-oriented language with classes and single
    inheritance. Every object is an instance of a class, and all classes
    descend from <ulink
    url="http://api.dartlang.org/dart_core/Object.html">Object.</ulink></para>

    <para>To create an object, you can use the <literal
    moreinfo="none">new</literal> keyword with a
    <firstterm>constructor</firstterm> for a class. Constructor names can be
    either <emphasis><replaceable>ClassName</replaceable></emphasis> or
    <replaceable>ClassName.identifier</replaceable>. For example:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var jsonData = json.parse('{"x":1, "y":2}');

var p1 = new Point(2,2);               // Create a Point using Point().
var p2 = new Point.fromJson(jsonData); // Create a Point using Point.fromJson().</programlisting>

    <para>Objects have <firstterm>members</firstterm> consisting of functions
    and data (<firstterm>methods</firstterm> and <firstterm>instance
    variables</firstterm>, respectively). When you call a method, you
    <emphasis>invoke</emphasis> it on an object: the method has access to that
    object’s functions and data.</para>

    <para>Use a dot (.) to refer to an instance variable or method:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var p = new Point(2,2);

p.y = 3;             // Set the value of the instance variable y.
assert(p.y == 3);    // Get the value of y.

num distance = p.distanceTo(new Point(4,4)); // Invoke distanceTo() on p.</programlisting>

    <para>Use the cascade operator (..) when you want to perform a series of
    operations on the members of a single object:</para>

    <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>query('#button')
    ..text = 'Click to Confirm'                        // Get an object. Use its
    ..classes.add('important')                         // instance variables
    ..onClick.listen((e) =&gt; window.alert('Confirmed!')); // and methods.</programlisting>

    <para>Some classes provide constant constructors. To create a compile-time
    constant using a constant constructor, use <literal
    moreinfo="none">const</literal> instead of <literal
    moreinfo="none">new</literal>:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var p = const ImmutablePoint(2,2);</programlisting>

    <para>Constructing two identical compile-time constants results in a
    single, canonical <phrase role="keep-together">instance:</phrase></para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a,b)); // They are the same instance!</programlisting>

    <para>The following sections discuss how to implement classes.</para>

    <sect2 id="ch02-instance-variables">
      <title>Instance Variables</title>

      <para>Here’s how you declare instance variables:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/instance_variables.dart
</remark>class Point {
  num x;      // Declare an instance variable (x), initially null.
  num y;      // Declare y, initially null.
  num z = 0;  // Declare z, initially 0.
}</programlisting>

      <para>All uninitialized instance variables have the value <literal
      moreinfo="none">null</literal>.</para>

      <para>All instance variables generate an implicit
      <firstterm>getter</firstterm> method. Non-final, non-const instance
      variables also generate an implicit <firstterm>setter</firstterm>
      method. For details, see <xref
      linkend="classes-getters-and-setters" />.</para>

      <programlisting format="linespecific" role=""><remark>lang-dart
</remark><remark>ch02/instance_variables.dart
</remark>class Point {
  num x;
  num y;
}

main() {
  var point = new Point();
  point.x = 4;             // Use the setter method for x.
  assert(point.x == 4);    // Use the getter method for x.
  assert(point.y == null); // Values default to null.
}</programlisting>

      <para>If you initialize an instance variable where it is declared
      (instead of in a constructor or method), the value is set when the
      instance is created, which is before the constructor and its initializer
      list execute.</para>
    </sect2>

    <sect2 id="ch02-constructors">
      <title>Constructors</title>

      <para>Declare a constructor by creating a function with the same name as
      its class (plus, optionally, an additional identifier as described in
      <xref linkend="ch02-constructors-named" />). The most common form of
      constructor, the generative constructor, creates a new instance of a
      class:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/constructor_long_way.dart
</remark>class Point {
  num x;
  num y;

  Point(num x, num y) {
    // There's a better way to do this, stay tuned.
    this.x = x;
    this.y = y;
  }
}</programlisting>

      <para>The <literal moreinfo="none">this</literal> keyword refers to the
      current instance.</para>

      <note>
        <para>Use <literal moreinfo="none">this</literal> only when there is a
        name conflict. Otherwise, Dart style omits the <literal
        moreinfo="none">this</literal>.</para>
      </note>

      <para>The pattern of assigning a constructor argument to an instance
      variable is so common, Dart has syntactic sugar to make it easy:</para>

      <programlisting format="linespecific" role="keep-together"><remark>lang-dart
</remark>class Point {
  num x;
  num y;

  // Syntactic sugar for setting x and y before the constructor body runs.
  Point(this.x, this.y);
}</programlisting>

      <sect3 id="ch02-constructors-default">
        <title>Default constructors</title>

        <para>If you don’t declare a constructor, a default constructor is
        provided for you. The default constructor has no arguments and invokes
        the no-argument constructor in the <phrase
        role="keep-together">superclass</phrase>.</para>
      </sect3>

      <sect3 id="ch02-constructors-not-inherited">
        <title>Constructors aren’t inherited</title>

        <para>Subclasses don’t inherit constructors from their superclass. A
        subclass that declares no constructors has only the default (no
        argument, no name) constructor.</para>
      </sect3>

      <sect3 id="ch02-constructors-named">
        <title>Named constructors</title>

        <para>Use a named constructor to implement multiple constructors for a
        class or to provide extra clarity:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/named_constructor.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Named constructor
  Point.fromJson(Map json) {
    x = json['x'];
    y = json['y'];
  }
}</programlisting>

        <para>Remember that constructors are not inherited, which means that a
        superclass’s named constructor is not inherited by a subclass. If you
        want a subclass to be created with a named constructor defined in the
        superclass, you must implement that constructor in the
        subclass.</para>
      </sect3>

      <sect3 id="ch02-constructor-non-default-superclass">
        <title>Invoking a non-default superclass constructor</title>

        <para>By default, a constructor in a subclass calls the superclass’s
        unnamed, no-argument constructor. If the superclass doesn’t have such
        a constructor, then you must manually call one of the constructors in
        the superclass. Specify the superclass constructor after a colon
        (<literal>:</literal>), just before the constructor body (if
        any).</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/op_as.dart
</remark>class Person {
  Person.fromJson(Map data) {
    print('in Person');
  }
}

class Employee extends Person {
  // Person does not have a default constructor;
  // you must call super.fromJson(data).
  Employee.fromJson(Map data) : super.fromJson(data) {
    print('in Employee');
  }
}

main() {
  var emp = new Employee.fromJson({});

  // Prints:
  // in Person
  // in Employee
}</programlisting>
      </sect3>

      <sect3 id="ch02-constructor-initializer-list">
        <title>Initializer list</title>

        <para>Besides invoking a superclass constructor, you can also
        initialize instance variables before the constructor body runs.
        Separate initializers with commas.</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/initializer_list.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // Initializer list sets instance variables before the constructor body runs.
  Point.fromJson(Map json) : x = json['x'], y = json['y'] {
    print('In Point.fromJson(): ($x, $y)');
  }
}</programlisting>

        <warning>
          <para>The right-hand side of an initializer does not have access to
          <literal moreinfo="none">this</literal>.</para>
        </warning>
      </sect3>

      <sect3 id="ch02-constructor-redirecting">
        <title>Redirecting constructors</title>

        <para>Sometimes a constructor’s only purpose is to redirect to another
        constructor in <phrase role="keep-together">the same class.</phrase> A
        redirecting constructor’s body is empty, with the constructor call
        <phrase role="keep-together">appearing after a colon
        (:).</phrase></para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/along_x_axis.dart
</remark>class Point {
  num x;
  num y;

  Point(this.x, this.y);                // The main constructor for this class.
  Point.alongXAxis(num x) : this(x, 0); // Delegates to the main constructor.
}</programlisting>
      </sect3>

      <sect3 id="ch02-constructor-constant">
        <title>Constant constructors</title>

        <para>If your class produces objects that never change, you can make
        these objects compile-time constants. To do this, define a <literal
        moreinfo="none">const</literal> constructor and make sure that all
        instance variables are <literal moreinfo="none">final</literal> or
        <literal moreinfo="none">const</literal>.</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/immutable_point.dart
</remark>class ImmutablePoint {
  final num x;
  final num y;
  const ImmutablePoint(this.x, this.y);
  static final ImmutablePoint origin = const ImmutablePoint(0, 0);
}</programlisting>
      </sect3>

      <sect3 id="ch02-constructor-factory">
        <title>Factory constructors</title>

        <para>Use the <literal moreinfo="none">factory</literal> keyword when
        implementing a constructor that doesn’t always create a new instance
        of its class. For example, a factory constructor might return an
        instance from a cache, or it might return an instance of a
        subtype.</para>

        <para>The following example demonstrates a factory constructor
        returning objects from a cache:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/factory_constructor.dart
</remark>class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{};
  
  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }
  
  Logger._internal(this.name);
  
  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}</programlisting>

        <note>
          <para>Factory constructors have no access to <literal
          moreinfo="none">this</literal>.</para>
        </note>

        <para>To invoke a factory constructor, you use the <literal
        moreinfo="none">new</literal> keyword:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/factory_constructor.dart
</remark>var logger = new Logger('UI');
logger.log('Button clicked');</programlisting>
      </sect3>
    </sect2>

    <sect2 id="ch02-methods">
      <title>Methods</title>

      <para>Methods are functions that provide behavior for an object.</para>

      <sect3 id="ch02-methods-instance">
        <title>Instance methods</title>

        <para>Instance methods on objects can access instance variables and
        <literal moreinfo="none">this</literal>. The
        <literal>distanceTo()</literal> method in the following sample is an
        example of an instance method:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/distance_to.dart
</remark>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  num distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}</programlisting>
      </sect3>

      <sect3 id="classes-getters-and-setters">
        <title>Getters and setters</title>

        <para>Getters and setters are special methods that provide read and
        write access to an object’s properties. Recall that each instance
        variable has an implicit getter, plus a setter if appropriate. You can
        create additional properties by implementing getters and setters,
        using the <literal moreinfo="none">get</literal> and <literal
        moreinfo="none">set</literal> keywords:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/rectangle.dart
</remark>class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  num get right             =&gt; left + width;
      set right(num value)  =&gt; left = value - width;
  num get bottom            =&gt; top + height;
      set bottom(num value) =&gt; top = value - height;
}

main() {
  var rect = new Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}</programlisting>

        <para>With getters and setters, you can start with instance variables,
        later wrapping them with methods, all without changing client
        code.</para>

        <para><note>
            <para>Operators such as increment (++) work in the expected way,
            whether or not a getter is explicitly defined. To avoid any
            unexpected side effects, the operator calls the getter exactly
            once, saving its value in a temporary variable.</para>
          </note></para>
      </sect3>

      <sect3 id="ch02-method-abstract">
        <title>Abstract methods</title>

        <para>Instance, getter, and setter methods can be abstract, defining
        an interface but leaving its implementation up to other classes. To
        make a method abstract, use a semicolon (;) instead of a method
        body:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/doer.dart
</remark>abstract class Doer {
  // ...Define instance variables and methods...
 
  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // ...Provide an implementation, so the method is not abstract here...
  }
}</programlisting>

        <para>Calling an abstract method results in a run-time error.</para>

        <para>Also see <xref linkend="ch02-class-abstract" />.</para>
      </sect3>

      <sect3 id="classes-operators">
        <title>Overridable Operators</title>

        <para>You can override the operators shown in <xref
        linkend="overridden_operator_table" />. For example, if you define a
        Vector class, you might define a <literal>+</literal> method to add
        two vectors.</para>

        <table id="overridden_operator_table" role="keep-together">
          <title>Operators that can be overridden</title>

          <tgroup cols="4">
            <tbody>
              <row>
                <entry>&lt;</entry>

                <entry>+</entry>

                <entry>|</entry>

                <entry>[]</entry>
              </row>

              <row>
                <entry>&gt;</entry>

                <entry>/</entry>

                <entry>^</entry>

                <entry>[]=</entry>
              </row>

              <row>
                <entry>&lt;=</entry>

                <entry>~/</entry>

                <entry>&amp;</entry>

                <entry>~</entry>
              </row>

              <row>
                <entry>&gt;=</entry>

                <entry>*</entry>

                <entry>&lt;&lt;</entry>

                <entry>==</entry>
              </row>

              <row>
                <entry>–</entry>

                <entry>%</entry>

                <entry>&gt;&gt;</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Here’s an example of a class that overrides the <literal
        moreinfo="none">+</literal> and <literal moreinfo="none">-</literal>
        operators:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/vector.dart
</remark>class Vector {
  final int x;
  final int y;
  const Vector(this.x, this.y);

  Vector operator +(Vector v) { // Overrides + (a + b).
    return new Vector(x + v.x, y + v.y);
  }

  Vector operator -(Vector v) { // Overrides - (a - b).
    return new Vector(x - v.x, y - v.y);
  }
}

main() {
  final v = new Vector(2,3);
  final w = new Vector(2,2);

  assert(v.x == 2 &amp;&amp; v.y == 3);         // v   == (2,3)
  assert((v+w).x == 4 &amp;&amp; (v+w).y == 5); // v+w == (4,5)
  assert((v-w).x == 0 &amp;&amp; (v-w).y == 1); // v-w == (0,1)
}</programlisting>

        <para>For an example of overriding <literal
        moreinfo="none">==</literal>, see <xref
        linkend="ch03-implementing-map-keys" />.</para>
      </sect3>
    </sect2>

    <sect2 id="ch02-class-abstract">
      <title>Abstract Classes</title>

      <para>Use the <literal moreinfo="none">abstract</literal> modifier to
      define an <firstterm>abstract class</firstterm>—a class that can’t be
      instantiated. Abstract classes are useful for defining interfaces, often
      with some implementation. If you want your abstract class to appear to
      be instantiable, define a <link
      linkend="ch02-constructor-factory">factory constructor</link>.</para>

      <para>Abstract classes often have <link
      linkend="ch02-method-abstract">abstract methods</link>. Here’s an
      example of declaring an abstract class that has an abstract
      method:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/abstract.dart
</remark>// This class is declared abstract and thus can't be instantiated.
abstract class AbstractContainer {
  // ...Define constructors, fields, methods...

  void updateChildren(); // Abstract method.
}</programlisting>

      <para>The following class isn’t abstract, and thus can be instantiated
      even though it defines an abstract method:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/abstract.dart
</remark>class SpecializedContainer extends AbstractContainer {
  // ...Define more constructors, fields, methods...

  void updateChildren() {
    // ...Implement updateChildren()...
  }
// Abstract method causes a warning but doesn't prevent instantiatation.
  void doSomething(); 
}</programlisting>
    </sect2>

    <sect2 id="ch02-implicit-interfaces">
      <title>Implicit Interfaces</title>

      <para>Every class implicitly defines an interface containing all the
      instance members of the class and of any interfaces it implements. If
      you want to create a class A that supports class B’s API without
      inheriting B’s implementation, class A should implement the B
      interface.</para>

      <para>A class implements one or more interfaces by declaring them in an
      <literal moreinfo="none">implements</literal> clause and then providing
      the APIs required by the interfaces. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/imposter.dart
</remark>// A person. The implicit interface contains greet().
class Person {
  final _name;          // In the interface, but visible only in this library,
  Person(this._name);   // Not in the interface, since this is a constructor.
  String greet(who) =&gt; 'Hello, $who. I am $_name.'; // In the interface.
}

// An implementation of the Person interface.
class Imposter implements Person {
  final _name = "";      // We have to define this, but we don't use it.
  String greet(who) =&gt; 'Hi $who. Do you know who I am?';
}

greetBob(Person person) =&gt; person.greet('bob');

main() {
  print(greetBob(new Person('kathy')));
  print(greetBob(new Imposter()));
}</programlisting>

      <para>Here’s an example of specifying that a class implements multiple
      interfaces:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/point_interfaces.dart
</remark>class Point <emphasis role="bold">implements Comparable, Location</emphasis> {
  // ...
}</programlisting>
    </sect2>

    <sect2 id="ch02-class-extend">
      <title>Extending a Class</title>

      <para>Use <literal moreinfo="none">extends</literal> to create a
      subclass, and <literal moreinfo="none">super</literal> to refer to the
      superclass:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>smart_tv.dart
</remark>class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  ...
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  ...
}</programlisting>

      <para>Subclasses can override instance methods, getters, and setters.
      Here’s an example of overriding the Object class’s
      <literal>noSuchMethod()</literal> method, which is called whenever code
      attempts to use a non-existent method or instance variable:</para>

      <programlisting><remark>lang-dart
</remark><remark>ch02/no_such_method.dart
</remark>class A {
  // Unless you override noSuchMethod, using a non-existent member
  // results in a NoSuchMethodError.
  void noSuchMethod(Invocation mirror) {
    print('You tried to use a non-existent member: ${mirror.memberName}');
  }
}</programlisting>
    </sect2>

    <sect2 id="ch02-class-vars-and-methods">
      <title>Class Variables and Methods</title>

      <para>Use the <literal moreinfo="none">static</literal> keyword to
      implement class-wide variables and methods.</para>

      <sect3 id="ch02-static-variables">
        <title>Static variables</title>

        <para>Static variables (class variables) are useful for class-wide
        state and constants:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/color.dart
</remark>class Color {
  static const RED = const Color('red'); // A constant static variable.
  final String name;                     // An instance variable.
  const Color(this.name);                // A constant constructor.
}

main() {
  assert(Color.RED.name == 'red');
}</programlisting>

        <para>Static variables aren’t initialized until they’re used.</para>
      </sect3>

      <sect3 id="ch02-static-methods">
        <title>Static methods</title>

        <para>Static methods (class methods) do not operate on an instance,
        and thus do not have access to <literal
        moreinfo="none">this</literal>. For example:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/point.dart
</remark>import 'dart:math';

class Point {
  num x;
  num y;
  Point(this.x, this.y);

  static num distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

main() {
  var a = new Point(2, 2);
  var b = new Point(4, 4);
  var distance = Point.distanceBetween(a,b);
  assert(distance &lt; 2.9 &amp;&amp; distance &gt; 2.8);
}</programlisting>

        <note>
          <para>Consider using top-level functions, instead of static methods,
          for common or widely used utilities and functionality.</para>
        </note>

        <para>You can use static methods as compile-time constants. For
        example, you can pass a static method as a parameter to a constant
        constructor.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="generics">
    <title>Generics</title>

    <para>If you look at the API documentation for the basic array type,
    <ulink url="http://api.dartlang.org/dart_core/List.html">List,</ulink>
    you’ll see that the type is actually <literal
    moreinfo="none">List&lt;E&gt;</literal>. The &lt;...&gt; notation marks
    List as a <emphasis>generic</emphasis> (or
    <emphasis>parameterized</emphasis>) type—a type that has formal type
    parameters. By convention, type variables have single-letter names, such
    as E, T, S, K, and V.</para>

    <sect2 id="ch02-generics-why">
      <title>Why Use Generics?</title>

      <para>Because types are optional in Dart, you never
      <emphasis>have</emphasis> to use generics. You might
      <emphasis>want</emphasis> to, though, for the same reason you might want
      to use other types in your code: types (generic or not) let you document
      and annotate your code, making your intent clearer.</para>

      <para>For example, if you intend for a list to contain only strings, you
      can declare it as <literal moreinfo="none">List&lt;String&gt;</literal>
      (read that as <quote>list of string</quote>). That way you, your fellow
      programmers, and your tools (such as Dart Editor and the Dart VM in
      checked mode) can detect that assigning a non-string to the list is
      probably a mistake. Here’s an example:</para>

      <programlisting format="linespecific"><remark>lang-dart</remark><remark>
ch02/generics.dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
// ...
names.add(42); // Fails in checked mode (succeeds in production mode).</programlisting>

      <para>Another reason for using generics is to reduce code duplication.
      Generics let you share a single interface and implementation between
      many types, while still taking advantage of checked mode and static
      analysis early warnings. For example, say you create an interface for
      caching an object:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class ObjectCache {
  Object getByKey(String key);
  setByKey(String key, Object value);
}</programlisting>

      <para>You discover that you want a string-specific version of this
      interface, so you create another interface:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class StringCache {
  String getByKey(String key);
  setByKey(String key, String value);
}</programlisting>

      <para>Later, you decide you want a number-specific version of this
      interface... You get the idea.</para>

      <para>Generic types can save you the trouble of creating all these
      interfaces. Instead, you can create a single interface that takes a type
      parameter:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>abstract class Cache&lt;T&gt; {
  T getByKey(String key);
  setByKey(String key, T value);
}</programlisting>

      <para>In this code, T is the stand-in type. It’s a placeholder that you
      can think of as a type that a developer will define later.</para>
    </sect2>

    <sect2 id="generics-literals">
      <title>Using Collection Literals</title>

      <para>List and map literals can be parameterized. Parameterized literals
      are just like the literals you’ve already seen, except that you add
      <literal
      moreinfo="none">&lt;<replaceable>type</replaceable>&gt;</literal> (for
      lists) or <literal
      moreinfo="none">&lt;<replaceable>keyType</replaceable>,
      <replaceable>valueType</replaceable>&gt;</literal> (for maps) before the
      opening bracket. You might use parameterized literals when you want type
      warnings in checked mode. Here is example of using typed
      literals:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];
var pages = &lt;String, String&gt;{
    'index.html':'Homepage',
    'robots.txt':'Hints for web robots',
    'humans.txt':'We are people, not machines' };</programlisting>

      <note>
        <para>Map literals always have string <emphasis>keys</emphasis>, so
        their type is always <phrase role="keep-together"><literal
        moreinfo="none">&lt;String,
        <replaceable>SomeType</replaceable>&gt;</literal>.</phrase></para>
      </note>
    </sect2>

    <sect2 id="generics-constructors">
      <title>Using Constructors</title>

      <para>To specify one or more types when using a constructor, put the
      types in angle brackets (<literal moreinfo="none">&lt;...&gt;</literal>)
      just after the class name. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
var nameSet = new Set&lt;String&gt;.from(names);</programlisting>

      <para>The following code creates a map that has integer keys and values
      of type View:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var views = new Map&lt;int, View&gt;();</programlisting>
    </sect2>

    <sect2 id="generics-collections">
      <title>Generic Collections and the Types they Contain</title>

      <para>Dart generic types are <emphasis>reified</emphasis>, which means
      that they carry their type information around at runtime. For example,
      you can test the type of a collection, even in production mode:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>var names = new List&lt;String&gt;();
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List&lt;String&gt;); // true</programlisting>

      <para>However, the <literal moreinfo="none">is</literal> expression
      checks the type of the <emphasis>collection</emphasis> only—not of the
      objects inside it. In production mode, a
      <literal>List&lt;String&gt;</literal> might have some non-string items
      in it. The solution is to either check each item’s type or wrap
      item-manipulation code in an exception handler (see <xref
      linkend="exceptions" />).</para>

      <note>
        <para>In contrast, generics in Java use <emphasis>erasure</emphasis>,
        which means that generic type parameters are removed at runtime. In
        Java, you can test whether an object is a List, but you can’t test
        whether it’s a <literal>List&lt;String&gt;</literal>.</para>
      </note>

      <para>For more information about generics, see <ulink
      url="http://www.dartlang.org/articles/optional-types/">Optional Types in
      Dart.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="libraries">
    <title>Libraries and Visibility</title>

    <para>The <literal moreinfo="none">import</literal>, <literal
    moreinfo="none">part</literal>, and <literal
    moreinfo="none">library</literal> directives can help you create a modular
    and shareable code base. Libraries not only provide APIs, but are a unit
    of privacy: identifiers that start with an underscore (_) are visible only
    inside the library. <emphasis>Every Dart app is a library</emphasis>, even
    if it doesn’t use a library directive.</para>

    <para>Libraries can be distributed using packages. See <xref
    linkend="ch04-tools-pub" /> for information about pub, a package manager
    included in the SDK.</para>

    <sect2 id="libraries-import">
      <title>Using Libraries</title>

      <para>Use <literal moreinfo="none">import</literal> to specify how a
      namespace from one library is used in the scope of another
      library.</para>

      <para>For example, Dart web apps generally use the <ulink
      url="http://api.dartlang.org/html.html">dart:html</ulink> library, which
      they can import like this:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/using_libraries.dart
</remark>import 'dart:html';</programlisting>

      <para>The only required argument to <literal
      moreinfo="none">import</literal> is a URI<footnote id="ch02-footnote-1">
          <para>URI stands for <firstterm>uniform resource
          identifier</firstterm>. URLs (<firstterm>uniform resource
          locators</firstterm>) are a common kind of URI.</para>
        </footnote> specifying the library. For built-in libraries, the URI
      has the special <literal moreinfo="none">dart:</literal> scheme. For
      other libraries, you can use a file system path or the <literal
      moreinfo="none">package:</literal> scheme. The <literal
      moreinfo="none">package:</literal> scheme specifies libraries provided
      by a package manager such as the pub tool. For example:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/using_schemes.dart, mylib, utils
</remark>import 'dart:io';
import 'package:mylib/mylib.dart';
import 'package:utils/utils.dart';</programlisting>

      <sect3 id="libraries-prefix">
        <title>Specifying a library prefix</title>

        <para>If you import two libraries that have conflicting identifiers,
        then you can specify a prefix for one or both libraries. For example,
        if library1 and library2 both have an Element class, then you might
        have code like this:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/library_prefix.dart, lib1, lib2
</remark>import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
// ...
var element1 = new Element();      // Uses Element from lib1.
var element2 = new lib2.Element(); // Uses Element from lib2.</programlisting>
      </sect3>

      <sect3 id="ch02-library-import-part">
        <title>Importing only part of a library</title>

        <para>If you want to use only part of a library, you can selectively
        import the library. For example:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/libraries/library_partil.dart, lib1, lib2
</remark>import 'package:lib1/lib1.dart' show foo, bar; // Import only foo and bar.
import 'package:lib2/lib2.dart' hide foo;      // Import all names EXCEPT foo.</programlisting>
      </sect3>
    </sect2>

    <sect2 id="libraries-implementing">
      <title>Implementing Libraries</title>

      <para>Use <literal moreinfo="none">library</literal> to name a library,
      and <literal moreinfo="none">part</literal> to specify additional files
      in the library.</para>

      <note>
        <para>You don’t have to use <literal>library</literal> in an app (a
        file that has a top-level main() function), but doing so lets you
        implement the app in multiple files.</para>
      </note>

      <sect3 id="libraries-library">
        <title>Declaring a library</title>

        <para>Use <literal moreinfo="none">library
        <replaceable>identifier</replaceable></literal> to specify the name of
        the current library:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ballgame.dart
</remark>library ballgame;   // Declare that this is a library named ballgame.

import 'dart:html'; // This app uses the HTML library.
// ...Code goes here...
</programlisting>
      </sect3>

      <sect3 id="libraries-source">
        <title>Associating a file with a library</title>

        <para>To add an implementation file, put <literal>part
        <replaceable>fileUri</replaceable></literal> in the file that has the
        <literal>library</literal> statement, where
        <emphasis>fileUri</emphasis> is the path to the implementation file.
        Then in the implementation file, put <literal>part of
        <replaceable>identifier</replaceable></literal>, where
        <emphasis>identifier</emphasis> is the name of the library. The
        following example uses <literal>part</literal> and <literal>part
        of</literal> to implement a library in three files.</para>

        <para>The first file, <literal>ballgame.dart</literal>, declares the
        ballgame library, imports other libraries it needs, and specifies that
        <literal>ball.dart</literal> and <literal>util.dart</literal> are
        parts of this library:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ballgame.dart
</remark>library ballgame;

import 'dart:html';
// ...Other imports go here...

part 'ball.dart';
part 'util.dart';

// ...Code might go here...</programlisting>

        <para>The second file, <literal>ball.dart</literal>, implements part
        of the ballgame library:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/ball.dart
</remark>part of ballgame;

// ...Code goes here...</programlisting>

        <para>The third file, <literal>util.dart</literal>, implements the
        rest of the ballgame library:</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/util.dart
</remark>part of ballgame;

// ...Code goes here...</programlisting>
      </sect3>

      <sect3 id="ch02-library-reexport">
        <title>Re-exporting libraries</title>

        <para>You can combine or repackage libraries by re-exporting part or
        all of them. For example, you might have a huge library that you
        implement as a set of smaller libraries. Or you might create a library
        that provides a subset of methods from another library.</para>

        <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/french.dart, togo.dart, french_togo.dart
</remark><emphasis>// In french.dart:</emphasis>
library french;
hello() =&gt; print('Bonjour!');
goodbye() =&gt; print('Au Revoir!');

<emphasis>// In togo.dart:</emphasis>
library togo;
import 'french.dart';
export 'french.dart' show hello;

<emphasis>// In another .dart file:
</emphasis>import 'togo.dart';

void main() {
  hello();   //print bonjour
  goodbye(); //FAIL
}</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="isolates">
    <title>Isolates</title>

    <para>Modern web browsers, even on mobile platforms, run on multi-core
    CPUs. To take advantage of all those cores, developers traditionally use
    shared-memory threads running concurrently. However, shared-state
    concurrency is error prone and can lead to complicated code.</para>

    <para>Instead of threads, all Dart code runs inside of
    <emphasis>isolates</emphasis>. Each isolate has its own memory heap,
    ensuring that no isolate’s state is accessible from any other
    isolate.</para>

    <para>Learn more about isolates in <xref
    linkend="ch03-dartisolate---concurrency-with-isolates" />.</para>
  </sect1>

  <sect1 id="typedefs">
    <title>Typedefs</title>

    <para>In Dart, functions are objects, just like strings and numbers are
    objects. A <emphasis>typedef</emphasis>, or <emphasis>function-type
    alias</emphasis>, gives a function type a name that you can use when
    declaring fields and return types. A typedef retains type information when
    a function type is assigned to a variable.</para>

    <para>Consider the following code, which does not use a typedef:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/sorted_collection.dart
</remark>class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);

  // All we know is that compare is a function, but what type of function?
  assert(collection.compare is Function);
}</programlisting>

    <para>Type information is lost when assigning <literal
    moreinfo="none">f</literal> to <literal moreinfo="none">compare</literal>.
    The type of <literal moreinfo="none">f</literal> is <literal
    moreinfo="none">(Object, </literal><phrase role="keep-together"><literal
    moreinfo="none">Object)</literal> <phrase role="unicode">→</phrase>
    <literal moreinfo="none">int</literal></phrase> (where <phrase
    role="unicode">→</phrase> means returns), yet the type of <literal
    moreinfo="none">compare</literal> is Function. If we change the code to
    use explicit names and retain type information, both developers and tools
    can use that information.</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark><emphasis role="">typedef int Compare(Object a, Object b);</emphasis>

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

int sort(Object a, Object b) =&gt; ... ; // Initial, broken implementation.

main() {
  SortedCollection collection = new SortedCollection(sort);
  assert(collection.compare is Function);
  assert(collection.compare is Compare);
}</programlisting>

    <note>
      <para>Currently, typedefs are restricted to function types. We expect
      this to change.</para>
    </note>

    <para>Because typedefs are simply aliases, they offer a way to check the
    type of any function. For example:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark>typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare);  // True!
}</programlisting>
  </sect1>

  <sect1 id="ch02-metadata">
    <title>Metadata</title>

    <para>Use metadata to give additional information about your code. A
    metadata annotation begins with the character <literal>@</literal>,
    followed by either a reference to a compile-time constant (such as
    <literal>deprecated</literal>) or a call to a constant constructor.</para>

    <para>The <ulink url="http://pub.dartlang.org/packages/meta">meta
    package</ulink> defines the API for two common annotations:
    <literal>@deprecated</literal> and <literal>@overrides</literal>. Here’s
    an example of using the <literal>@deprecated</literal> annotation:</para>

    <programlisting format="linespecific"><remark>lang-dart
ch02/metadata.dart
</remark>import 'package:meta/meta.dart'; // Defines deprecated.

class Television {
  /// _Deprecated: Use [turnOn] instead._
  @deprecated      // Metadata; makes Dart Editor warn about using activate().
  void activate() {
    turnOn();
  }

  /// Turns the TV's power on.
  void turnOn() {
    print('on!');
  }
} 
</programlisting>

    <para>You can define your own metadata annotations. For example, here’s
    how the meta package defines the <literal>deprecated</literal>
    constant:</para>

    <programlisting><remark>lang-dart</remark><remark>
ch02/metadata.dart
</remark>const deprecated = const _Deprecated();

class _Deprecated {
  const _Deprecated();
}
</programlisting>

    <para>Here’s an example of defining a @todo annotation that takes two
    arguments:</para>

    <programlisting><remark>lang-dart
</remark><remark>ch02/ch02_meta_create/todo.dart
</remark>library todo;

class todo {
  final String who;
  final String what;
  
  const todo(this.who, this.what);
}</programlisting>

    <para>And here’s an example of using that @todo annotation:</para>

    <programlisting><remark>lang-dart</remark><remark>
ch02/ch02_meta_create/metadata_user.dart
</remark>import 'todo.dart';

@todo('seth', 'make this do something')
void doSomething() {
  print('do something');
}</programlisting>

    <para>Metadata can appear before a library, class, typedef, type
    parameter, constructor, factory, function, field, parameter, or variable
    declaration and before an import or export directive. In the future,
    you’ll be able to retrieve metadata at runtime using reflection.</para>
  </sect1>

  <sect1 id="comments">
    <title>Comments</title>

    <para>Dart supports single-line comments, multi-line comments, and
    documentation <phrase role="keep-together">comments.</phrase></para>

    <sect2 id="ch02-comments-single-line">
      <title>Single-Line Comments</title>

      <para>A single-line comment begins with <literal
      moreinfo="none">//</literal>. Everything between <literal
      moreinfo="none">//</literal> and the end of line is ignored by the Dart
      compiler.</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark>main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}</programlisting>
    </sect2>

    <sect2 id="ch02-comments-multi-line">
      <title>Multi-Line Comments</title>

      <para>A multi-line comment begins with <literal
      moreinfo="none">/*</literal> and ends with <literal
      moreinfo="none">*/</literal>. Everything between <literal
      moreinfo="none">/*</literal> and <literal moreinfo="none">*/</literal>
      is ignored by the Dart compiler (unless the comment is a documentation
      comment; see the next section). Multi-line comments can nest.</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/multi_line_comments.dart
</remark>main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = new Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}</programlisting>
    </sect2>

    <sect2 id="comments-doc">
      <title>Documentation Comments</title>

      <para>Documentation comments are multi-line or single-line comments that
      begin with <literal moreinfo="none">/**</literal> or <literal
      moreinfo="none">///</literal>. Using <literal
      moreinfo="none">///</literal> on consecutive lines has the same effect
      as a multi-line doc comment.</para>

      <para>Inside a documentation comment, the Dart compiler ignores all text
      unless it is enclosed in brackets. Using brackets, you can refer to
      classes, methods, fields, top-level variables, functions, and
      parameters. The names in brackets are resolved in the lexical scope of
      the documented program element.</para>

      <para>Here is an example of documentation comments with references to
      other classes and arguments:</para>

      <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch02/doc_comments.dart
</remark>/**
 * The llama (Lama glama) is a domesticated South American
 * camelid, widely used as a meat and pack animal by Andean
 * cultures since pre-Hispanic times.
 */
class Llama {
  String name;

  /**
   * Feeds your llama [Food].
   * 
   * The typical llama eats one bale of hay per week.
   */
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}</programlisting>

      <para>In the generated documentation, <literal
      moreinfo="none">[Food]</literal> becomes a link to the API docs for the
      Food class.</para>

      <para>To parse Dart code and generate HTML documentation, you can use
      Dart Editor, which in turn uses the SDK’s dartdoc package. For an
      example of generated documentation, see the <ulink
      url="http://api.dartlang.org">Dart API documentation.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch02-summary">
    <title>Summary</title>

    <para>This chapter summarized the commonly used features in the Dart
    language. More features are being implemented, such as <ulink
    url="http://www.dartlang.org/articles/mixins/">mixins,</ulink> but we
    expect that they won’t break existing code. For more information, see the
    <ulink url="http://www.dartlang.org/docs/spec/">Dart Language
    Specification</ulink> and <ulink
    url="http://www.dartlang.org/articles/">articles</ulink> such as <ulink
    url="http://www.dartlang.org/articles/idiomatic-dart/"
    userlevel="">Idiomatic Dart.</ulink></para>
  </sect1>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch03">
  <?dbhtml stop-chunking?>

  <title>A Tour of the Dart Libraries</title>

  <para>This chapter shows you how to use the major features in Dart’s
  libraries. It’s just an overview, and by no means comprehensive. Whenever
  you need more details about a class, consult the <ulink
  url="http://api.dartlang.org/">Dart API reference. </ulink> Expect major
  changes to the Dart libraries before Dart’s first production release.</para>

  <sect1 id="ch03-dartcore---strings-collections-and-more">
    <title>dart:core - Numbers, Collections, Strings, and More</title>

    <para>The Dart core library provides a small but critical set of built-in
    functionality. This library is automatically imported into every Dart
    program.</para>

    <sect2 id="ch03-numbers">
      <title>Numbers</title>

      <para>The dart:core library defines the num, int, and double classes,
      which have some basic utilities for working with numbers.</para>

      <para>You can convert a string into an integer or double with the
      <literal>parse()</literal> methods of int and double,
      respectively:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/number-tests.dart
</remark>assert(int.parse('42') == 42);
assert(double.parse('0.50') == 0.5);</screen>

      <para>Use the <literal>toString()</literal> method (defined by <ulink
      url="http://api.dartlang.org/dart_core/Object.html">Object</ulink>) to
      convert an int or double to a string. To specify the number of digits to
      the right of the decimal, use <literal>toStringAsFixed()</literal>
      (defined by num). To specify the number of significant digits in the
      string, use <phrase
      role="keep-together"><literal>toStringAsPrecision()</literal>
      </phrase>(also in num):</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/number-tests.dart
</remark>// Convert an int to a string.
assert(42.toString() == '42');

// Convert a double to a string.
assert(123.456.toString() == '123.456');

// Specify the number of digits after the decimal.
assert(123.456.toStringAsFixed(2) == '123.46');

// Specify the number of significant figures.
assert(123.456.toStringAsPrecision(2) == '1.2e+2');
assert(double.parse('1.2e+2') == 120.0);</screen>

      <para>For more information, see the API documentation for <ulink
      url="http://api.dartlang.org/dart_core/int.html">int,</ulink> <ulink
      url="http://api.dartlang.org/dart_core/double.html">double,</ulink> and
      <ulink url="http://api.dartlang.org/dart_core/num.html">num.</ulink>
      Also see <xref lang="" linkend="ch03-dart-math" />.</para>
    </sect2>

    <sect2 id="ch03-strings-and-regular-expressions">
      <title>Strings and Regular Expressions</title>

      <para>A string in Dart is an immutable sequence of UTF-16 code units.
      The language tour has more information about <link
      linkend="strings">strings</link>. You can use regular expressions
      (RegExp objects) to search within strings and to replace parts of
      strings.</para>

      <para>The String class defines such methods as
      <literal>split()</literal>, <literal>contains()</literal>,
      <literal>startsWith()</literal>, <phrase
      role="keep-together"><literal>endsWith()</literal></phrase>, and
      more.</para>

      <sect3 id="ch03-searching-inside-a-string">
        <title>Searching inside a string</title>

        <para>You can find particular locations within a string, as well as
        check whether a string begins with or ends with a particular pattern.
        For example:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// Check whether a string contains another string.
assert('Never odd or even'.contains('odd'));

// Does a string start with another string?
assert('Never odd or even'.startsWith('Never'));

// Does a string end with another string?
assert('Never odd or even'.endsWith('even'));

// Find the location of a string inside a string.
assert('Never odd or even'.indexOf('odd') == 6);</screen>
      </sect3>

      <sect3 id="ch03-extracting-data-from-a-string">
        <title>Extracting data from a string</title>

        <para>You can get the individual characters or UTF-16 code units from
        a string as Strings or ints, respectively.</para>

        <para>You can also extract a substring or split a string into a list
        of substrings:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// Grab a substring.
assert('Never odd or even'.substring(6, 9) == 'odd');

// Split a string using a string pattern.
var parts = 'structured web apps'.split(' ');
assert(parts.length == 3);
assert(parts[0] == 'structured');

// Get a character (as a string) by index.
assert('Never odd or even'[0] == 'N');

// Use split() with an empty string parameter to get a list of
// all characters (as Strings); good for iterating.
for (var char in 'hello'.split('')) {
  print(char);
}

// Get all the characters in the string as a list of UTF-16 code units.
// Some characters might require two code units.
var codeUnitList = 'Never odd or even'.codeUnits.toList();
assert(codeUnitList[0] == 78);</screen>
      </sect3>

      <sect3 id="ch03-converting-to-uppercase-or-lowercase">
        <title>Converting to uppercase or lowercase</title>

        <para>You can easily convert strings to their uppercase and lowercase
        variants:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// Convert to uppercase.
assert('structured web apps'.toUpperCase() == 'STRUCTURED WEB APPS');

// Convert to lowercase.
assert('STRUCTURED WEB APPS'.toLowerCase() == 'structured web apps');</screen>
      </sect3>

      <sect3 id="ch03-trimming-and-empty-strings">
        <title>Trimming and empty strings</title>

        <para>Remove all leading and trailing white space with
        <literal>trim()</literal>. To check whether a string is empty (length
        is zero), use <literal>isEmpty</literal>.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// Trim a string.
assert('  hello  '.trim() == 'hello');

// Check whether a string is empty.
assert(''.isEmpty);

// Strings with only white space are not empty.
assert(!'  '.isEmpty);</screen>
      </sect3>

      <sect3 id="_replacing_part_of_a_string">
        <title>Replacing part of a string</title>

        <para>Strings are immutable objects, which means you can create them
        but you can’t change them. If you look closely at the <ulink
        url="http://api.dartlang.org/dart_core/String.html">String API
        docs,</ulink> you’ll notice that none of the methods actually changes
        the state of a String. For example, the method
        <literal>replaceAll()</literal> returns a new String without changing
        the original String:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>var greetingTemplate = 'Hello, NAME!';
var greeting = greetingTemplate.replaceAll(new RegExp('NAME'), 'Bob');

assert(greeting != greetingTemplate); // greetingTemplate didn't change.</screen>
      </sect3>

      <sect3 id="_building_a_string">
        <title>Building a string</title>

        <para>To programmatically generate a string, you can use StringBuffer.
        A StringBuffer doesn’t generate a new String object until
        <literal>toString()</literal> is called.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>var sb = new StringBuffer();

sb..write('Use a StringBuffer ')
  ..writeAll(['for ', 'efficient ', 'string ', 'creation'])
  ..write('.');

var fullString = sb.toString();

assert(fullString ==
    'Use a StringBuffer for efficient string creation.');</screen>
      </sect3>

      <sect3 id="ch03-regular-expressions">
        <title>Regular expressions</title>

        <para>The RegExp class provides the same capabilities as JavaScript
        regular expressions. Use regular expressions for efficient searching
        and pattern matching of strings.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>// A regular expression for one or more digits
var numbers = new RegExp(r'\d+');

var allCharacters = 'llamas live fifteen to twenty years';
var someDigits = 'llamas live 15 to 20 years';

// Contains() can use a regular expression.
assert(!allCharacters.contains(numbers));
assert(someDigits.contains(numbers));

// Replace every match with another string.
var exedOut = someDigits.replaceAll(numbers, 'XX');
assert(exedOut == 'llamas live XX to XX years');</screen>

        <para>You can work directly with the RegExp class, too. The Match
        class provides access to a regular expression match.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/string-tests.dart
</remark>var numbers = new RegExp(r'\d+');
var someDigits = 'llamas live 15 to 20 years';

// Check whether the reg exp has a match in a string.
assert(numbers.hasMatch(someDigits));

// Loop through all matches.
for (var match in numbers.allMatches(someDigits)) {
  print(match.group(0)); // 15, then 20
}</screen>
      </sect3>

      <sect3 id="ch03-more-information-8">
        <title>More information</title>

        <para>Refer to the <ulink
        url="http://api.dartlang.org/dart_core/String.html">String API
        docs</ulink> for a full list of methods. Also see the API docs for
        <ulink
        url="http://api.dartlang.org/dart_core/StringBuffer.html">StringBuffer,</ulink>
        <ulink
        url="http://api.dartlang.org/dart_core/Pattern.html">Pattern,</ulink>
        <ulink
        url="http://api.dartlang.org/dart_core/RegExp.html">RegExp,</ulink>
        and <ulink
        url="http://api.dartlang.org/dart_core/Match.html">Match.</ulink></para>
      </sect3>
    </sect2>

    <sect2 id="ch03-collections">
      <title>Collections</title>

      <para>Dart ships with a core collections API, which includes classes for
      lists, sets, and maps.</para>

      <sect3 id="ch03-lists">
        <title>Lists</title>

        <para>As the language tour shows, you can use literals to create and
        initialize <link linkend="lists">lists</link>. Alternatively, use one
        of the List constructors. The List class also defines several methods
        for adding items to and removing items from lists.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/list-tests.dart
</remark>// Use a List constructor.
var vegetables = new List();

// Or simply use a list literal.
var fruits = ['apples', 'oranges'];

// Add to a list.
fruits.add('kiwis');

// Add multiple items to a list.
fruits.addAll(['grapes', 'bananas']);

// Get the list length.
assert(fruits.length == 5);

// Remove a single item.
var appleIndex = fruits.indexOf('apples');
fruits.removeAt(appleIndex);
assert(fruits.length == 4);

// Remove all elements from a list.
fruits.clear();
assert(fruits.length == 0);</screen>

        <para>Use <literal>indexOf()</literal> to find the index of an object
        in a list:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/list-tests.dart
</remark>var fruits = ['apples', 'oranges'];

// Access a list item by index.
assert(fruits[0] == 'apples');

// Find an item in a list.
assert(fruits.indexOf('apples') == 0);</screen>

        <para>Sort a list using the <literal>sort()</literal> method. You must
        provide a sorting function that compares two objects. This sorting
        function must return &lt; 0 for <emphasis>smaller</emphasis>, 0 for
        the <emphasis>same</emphasis>, and &gt; 0 for
        <emphasis>bigger</emphasis>. The following example uses
        <literal>compareTo()</literal>, which is defined by <ulink
        url="http://api.dartlang.org/dart_core/Comparable.html">Comparable</ulink>
        and implemented by String.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/list-tests.dart
</remark>var fruits = ['bananas', 'apples', 'oranges'];

// Sort a list.
fruits.sort((a, b) =&gt; a.compareTo(b));
assert(fruits[0] == 'apples');</screen>

        <para>Lists are parameterized types, so you can specify the type that
        a list should contain:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/list-tests.dart
</remark>// This list should contain only strings.
var fruits = new List&lt;String&gt;();

fruits.add('apples');
var fruit = fruits[0];
assert(fruit is String);

// Generates static analysis warning, num is not a string.
fruits.add(5);  // BAD: Throws exception in checked mode.</screen>

        <para>Refer to the <ulink
        url="http://api.dartlang.org/dart_core/List.html">List API
        docs</ulink> for a full list of methods.</para>
      </sect3>

      <sect3 id="ch03-sets">
        <title>Sets</title>

        <para>A set in Dart is an unordered collection of unique items.
        Because a set is unordered, you can’t get a set’s items by index
        (position).</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/set-tests.dart
</remark>var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);
assert(ingredients.length == 3);

// Adding a duplicate item has no effect.
ingredients.add('gold');
assert(ingredients.length == 3);

// Remove an item from a set.
ingredients.remove('gold');
assert(ingredients.length == 2);</screen>

        <para>Use <literal>contains()</literal> and
        <literal>containsAll()</literal> to check whether one or more objects
        are in a set:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/set-tests.dart
</remark>var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);

// Check whether an item is in the set.
assert(ingredients.contains('titanium'));

// Check whether all the items are in the set.
assert(ingredients.containsAll(['titanium', 'xenon']));</screen>

        <para>An intersection is a set whose items are in two other
        sets.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/set-tests.dart
</remark>var ingredients = new Set();
ingredients.addAll(['gold', 'titanium', 'xenon']);

// Create the intersection of two sets.
var nobleGases = new Set.from(['xenon', 'argon']);
var intersection = ingredients.intersection(nobleGases);
assert(intersection.length == 1);
assert(intersection.contains('xenon'));</screen>

        <para>Refer to the <ulink
        url="http://api.dartlang.org/dart_core/Set.html">Set API docs</ulink>
        for a full list of methods.</para>
      </sect3>

      <sect3 id="ch03-maps-aka-dictionaries-or-hashes">
        <title>Maps</title>

        <para>A map, commonly known as a <emphasis>dictionary</emphasis> or
        <emphasis>hash</emphasis>, is an unordered collection of key-value
        pairs. Maps associate a key to some value for easy retrieval. Unlike
        in JavaScript, Dart objects are not maps.</para>

        <para><phrase role="keep-together">You can declare a map using a terse
        literal syntax, or you can use a traditional
        constructor:</phrase></para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>// Map literals use strings as keys.
var hawaiianBeaches = {
  'oahu' : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai' : ['hanalei', 'poipu']
};

// Maps can be built from a constructor.
var searchTerms = new Map();

// Maps are parameterized types; you can specify what types
// the key and value should be.
var nobleGases = new Map&lt;int, String&gt;();</screen>

        <para>You add, get, and set map items using the bracket syntax. Use
        <literal>remove()</literal> to remove a key and its value from a
        map.<remark> [PENDING: It’s questionable that this example uses
        containsKey before containsKey is discussed.]</remark></para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>var nobleGases = new Map&lt;int, String&gt;();

// Maps from constructors can use any object as a key.
// Integers and strings are common key types.
nobleGases[54] = 'xenon';

// Retrieve a value with a key.
assert(nobleGases[54] == 'xenon');

// Check whether a map contains a key.
assert(nobleGases.containsKey(54));

// Remove a key and its value.
nobleGases.remove(54);
assert(!nobleGases.containsKey(54));</screen>

        <para>You can retrieve all the values or all the keys from a
        map:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>var hawaiianBeaches = {
  'oahu' : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai' : ['hanalei', 'poipu']
};

// Get all the keys as an unordered collection (an Iterable).
var keys = hawaiianBeaches.keys;

assert(keys.length == 3);
assert(new Set.from(keys).contains('oahu'));

// Get all the values as an unordered collection (an Iterable of Iterables).
var values = hawaiianBeaches.values;
assert(values.length == 3);
assert(values.any((v) =&gt; v.indexOf('waikiki') != -1));</screen>

        <para>To check whether a map contains a key, use
        <literal>containsKey()</literal>. Because map values can be null, you
        cannot rely on simply getting the value for the key and checking for
        null to determine the existence of a key.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>var hawaiianBeaches = {
  'oahu' : ['waikiki', 'kailua', 'waimanalo'],
  'big island' : ['wailea bay', 'pololu beach'],
  'kauai' : ['hanalei', 'poipu']
};

assert(hawaiianBeaches.containsKey('oahu'));
assert(!hawaiianBeaches.containsKey('florida'));</screen>

        <para>Use the <literal>putIfAbsent()</literal> method when you want to
        assign a value to a key if and only if the key does not already exist
        in a map. You must provide a function that returns the value.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>var teamAssignments = {};
teamAssignments.putIfAbsent('Catcher', () =&gt; pickToughestKid());
assert(teamAssignments['Catcher'] != null);</screen>

        <para>Refer to the <ulink
        url="http://api.dartlang.org/dart_core/Map.html">Map API docs</ulink>
        for a full list of methods.</para>
      </sect3>

      <sect3 id="ch03-common-collection-methods">
        <title>Common collection methods</title>

        <para>List, Set, and Map share common functionality found in many
        collections. Some of this common functionality is defined by the
        Iterable class, which List and Set implement.</para>

        <note>
          <para>Although Map doesn’t implement Iterable, you can get Iterables
          from it using the Map <literal>keys</literal> and
          <literal>values</literal> properties.</para>
        </note>

        <para>Use <literal>isEmpty</literal> to check whether a list, set, or
        map has no items:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-isEmpty.dart
</remark>var teas = ['green', 'black', 'chamomile', 'earl grey'];
assert(!teas.isEmpty);</screen>

        <para>To apply a function to each item in a list, set, or map, you can
        use <literal>forEach()</literal>:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-apply-function.dart
</remark>var teas = ['green', 'black', 'chamomile', 'earl grey'];

teas.forEach((tea) =&gt; print('I drink $tea'));</screen>

        <para>When you invoke <literal>forEach()</literal> on a map, your
        function must take two arguments (the key and value):</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-1.dart
</remark>// NOTE: Do not depend on iteration order.
hawaiianBeaches.forEach((k,v) {
  print('I want to visit $k and swim at $v');
  // I want to visit oahu and swim at [waikiki, kailua, waimanalo], etc.
});</screen>

        <para>An alternative for Iterables is the <literal>map()</literal>
        method, which gives you all the results in a single object:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-apply-function.dart
</remark>var teas = ['green', 'black', 'chamomile', 'earl grey'];

var loudTeas = teas.map((tea) =&gt; tea.toUpperCase());
loudTeas.forEach(print);</screen>

        <note>
          <para>The object returned by <literal>map()</literal> is an Iterable
          that’s <emphasis>lazily evaluated</emphasis>: your function isn’t
          called until you ask for an item from the returned object.</para>
        </note>

        <para>To force your function to be called immediately on each item,
        use <literal>map().toList()</literal> or
        <literal>map().toSet()</literal>:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-apply-function.dart
</remark>var loudTeaList = teas.map((tea) =&gt; tea.toUpperCase()).toList();</screen>

        <para>Use Iterable’s <literal>where()</literal> method to get all the
        items that match a condition. Use Iterable’s <literal>any()</literal>
        and <literal>every()</literal> methods to check whether some or all
        items match a condition.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/collection-any-every.dart
</remark>var teas = ['green', 'black', 'chamomile', 'earl grey'];

// Chamomile is not caffeinated.
bool isDecaffeinated(String teaName) =&gt; teaName == 'chamomile';

// Use where() to find only the items that return true
// from the provided function.
var decaffeinatedTeas = teas.where((tea) =&gt; isDecaffeinated(tea));
// or teas.where(isDecaffeinated)

// Use any() to check whether at least one item in the collection
// satisfies a condition.
assert(teas.any(isDecaffeinated));

// Use every() to check whether all the items in a collection
// satisfy a condition.
assert(!teas.every(isDecaffeinated));</screen>

        <para>For a full list of methods, refer to the <ulink
        url="http://api.dartlang.org/dart_core/Iterable.html">Iterable API
        docs,</ulink> as well as those for List, Set, and Map.</para>
      </sect3>
    </sect2>

    <sect2 id="ch03-dates-and-times">
      <title>Dates and Times</title>

      <para>A DateTime object is a point in time. The time zone is either UTC
      or the local time zone.</para>

      <para>You can create DateTime objects using several constructors:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/date.dart
</remark>// Get the current date and time.
var now = new DateTime.now();

// Create a new DateTime with the local time zone.
var y2k = new DateTime(2000);   // January 1, 2000

// Specify the month and day.
y2k = new DateTime(2000, 1, 2); // January 2, 2000

// Specify the date as a UTC time.
y2k = new DateTime.utc(2000);   // January 1, 2000, UTC

// Specify a date and time in milliseconds since the Unix epoch.
y2k = new DateTime.fromMillisecondsSinceEpoch(946684800000, isUtc: true);

// Parse an ISO 8601 date.
y2k = DateTime.parse('2000-01-01T00:00:00Z');
</screen>

      <para>The <literal moreinfo="none">millisecondsSinceEpoch</literal>
      property of a date returns the number of milliseconds since the “Unix
      epoch”—January 1, 1970, UTC:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/date.dart
</remark>var y2k = new DateTime.utc(2000);           // 1/1/2000, UTC
assert(y2k.millisecondsSinceEpoch == 946684800000);
var unixEpoch = new DateTime.utc(1970); // 1/1/1970, UTC
assert(unixEpoch.millisecondsSinceEpoch == 0);</screen>

      <para>Use the Duration class to calculate the difference between two
      dates and to shift a date’s time forward or backwards:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/date.dart
</remark>var y2k = new DateTime.utc(2000);

// Add one year.
var y2001 = y2k.add(const Duration(days: 366));
assert(y2001.year == 2001);

// Subtract 30 days.
var december2000 = y2001.subtract(const Duration(days: 30));
assert(december2000.year == 2000);
assert(december2000.month == 12);

// Calculate the difference between two dates.
// Returns a Duration object.
var duration = y2001.difference(y2k);
assert(duration.inDays == 366); // y2k was a leap year.</screen>

      <para>Refer to the API docs for <ulink
      url="http://api.dartlang.org/dart_core/DateTime.html">DateTime</ulink>
      and <ulink
      url="http://api.dartlang.org/dart_core/Duration.html">Duration</ulink>
      for a full list of methods.</para>
    </sect2>

    <sect2 id="ch03-utility-interfaces">
      <title>Utility Classes</title>

      <para>The core library contains various utility classes, useful for
      sorting, mapping values, and iterating.</para>

      <sect3 id="ch03-comparing-objects">
        <title>Comparing objects</title>

        <para>Implement the <ulink
        url="http://api.dartlang.org/dart_core/Comparable.html">Comparable</ulink>
        interface to indicate that an object can be compared to another
        object, usually for sorting. The <literal>compareTo()</literal> method
        returns &lt; 0 for <emphasis>smaller</emphasis>, 0 for the
        <emphasis>same</emphasis>, and &gt; 0 for
        <emphasis>bigger</emphasis>.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/comparable.dart
</remark>class Line implements Comparable {
  final length;
  const Line(this.length);
  int compareTo(Line other) =&gt; length - other.length;
}

main() {
  var short = const Line(1);
  var long = const Line(100);
  assert(short.compareTo(long) &lt; 0);
}</screen>
      </sect3>

      <sect3 id="ch03-implementing-map-keys">
        <title>Implementing map keys</title>

        <para>Each object in Dart automatically provides an integer hash code,
        and thus can be used as a key in a map. However, you can override the
        <literal>hashCode</literal> getter to generate a custom hash code. If
        you do, be sure to override the <literal moreinfo="none">==</literal>
        operator, as well. Objects that are equal (via <literal
        moreinfo="none">==</literal>) must have identical hash codes. A hash
        code doesn’t have to be unique, but it should be well
        distributed.</para>

        <remark>Note: There’s disagreement over whether to include identical()
        in the == implementation. It might improve speed. They don’t do
        identical() automatically because, by convention, NaN != NaN.</remark>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/map-keys.dart
</remark>class Person {
  String firstName, lastName;

  Person(this.firstName, this.lastName);

  // Override hashCode using strategy from Effective Java, Chapter 11.
  int get hashCode {
    int result = 17;
    result = 37 * result + firstName.hashCode;
    result = 37 * result + lastName.hashCode;
    return result;
  }

  // Always implement operator== if you override hashCode.
  bool operator==(other) {
    if (identical(other, this)) return true;
    return (other.firstName == firstName &amp;&amp; other.lastName == lastName);
  }
}

main() {
  var p1 = new Person('bob', 'smith');
  var p2 = new Person('bob', 'smith');
  assert(p1.hashCode == p2.hashCode);
}</screen>
      </sect3>

      <sect3 id="ch03-iteration">
        <title>Iteration</title>

        <para>The <ulink
        url="http://api.dartlang.org/dart_core/Iterable.html">Iterable</ulink>
        and <ulink
        url="http://api.dartlang.org/dart_core/Iterator.html">Iterator</ulink>
        classes support for-in loops. Extend (if possible) or implement
        Iterable whenever you create a class that can provide Iterators for
        use in for-in loops. Implement Iterator to define the actual iteration
        ability.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/iterator.dart
</remark>class Process {
  // Represents a process...
}

class ProcessIterator implements Iterator&lt;Process&gt; {
  Process current;
  bool moveNext() {
    return false;
  }
}

// A mythical class that lets you iterate through all processes.
// Extends an Iterable subclass.
class Processes extends DoubleLinkedQueue&lt;Process&gt; {
  final Iterator&lt;Process&gt; iterator = new ProcessIterator();
}

main() {
  // Iterable objects can be used with for-in.
  for (var process in new Processes()) {
    // Do something with the process.
  }
}</screen>
      </sect3>
    </sect2>

    <sect2 id="ch03-exceptions">
      <title>Exceptions</title>

      <para>The Dart core library defines many common exceptions and errors.
      Exceptions are considered conditions that you can plan ahead for and
      catch. Errors are conditions that you don’t expect or plan for.</para>

      <para>A couple of the most common errors are:</para>

      <variablelist>
        <varlistentry>
          <term><ulink
          url="http://api.dartlang.org/dart_core/NoSuchMethodError.html">NoSuchMethodError</ulink></term>

          <listitem>
            <para>Thrown when a receiving object (which might be null) does
            not implement a <phrase
            role="keep-together">method</phrase>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><ulink
          url="http://api.dartlang.org/dart_core/ArgumentError.html">ArgumentError</ulink></term>

          <listitem>
            <para>Can be thrown by a method that encounters an unexpected
            argument.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Throwing an application-specific exception is a common way to
      indicate that an error has occurred. You can define a custom exception
      by implementing the Exception <phrase
      role="keep-together">interface</phrase>:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/exceptions.dart
</remark>class FooException implements Exception {
  final String msg;
  const FooException([this.msg]);
  String toString() =&gt; msg == null ? 'FooException' : msg;
}</screen>

      <para>For more information, see <xref linkend="exceptions" /> and the
      <ulink url="http://api.dartlang.org/dart_core/Exception.html">Exception
      API docs.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch03-asynchronous-programming">
    <title>dart:async - Asynchronous Programming</title>

    <para>Asynchronous programming often uses callback functions, but Dart
    provides an alternative: <ulink
    url="http://api.dartlang.org/dart_async/Future.html">Future</ulink>
    objects. A Future is like a promise for a result to be provided sometime
    in the future.</para>

    <para>You have the option of using a <ulink
    url="http://api.dartlang.org/dart_async/Completer.html">Completer</ulink>
    to produce a Future and, later, to supply a value to the Future.
    Completer, Future, and more are in the <ulink
    url="http://api.dartlang.org/dart_async.html">dart:async</ulink>
    library.</para>

    <para>The dart:async library works in both web apps and command-line apps.
    To use it, import <literal>dart:async</literal>.</para>

    <sect2 id="ch03-future-example">
      <title>Using Future and Completer</title>

      <para>In the following example, the
      <literal>longExpensiveSearch()</literal> function schedules a query and
      immediately returns a Future object. Later, when the query finishes in
      some <phrase role="keep-together">future event loop iteration</phrase>,
      the completer completes with the results. The completion signals that
      the Future has a value, which runs the callback registered in <phrase
      role="keep-together">Future’s <literal>then()</literal>.</phrase></para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/futures.dart</remark>Future longExpensiveSearch() {
var completer = new Completer();

// Perform exhaustive search.
dbQuery('select * from table', onSuccess: (results) {
  // Sometime later,
  // found it!!
  completer.complete(results);
});

return completer.future;
}

Future doSearch() {
var future = longExpensiveSearch(); // Returns immediately.

return future.then((results) {
  // The following code executes when the operation is complete.
  print('Here are the results: $results');
});
}</screen>
    </sect2>

    <sect2 id="ch03-future-error-handling">
      <title>Error Handling with Futures</title>

      <para>If an error or exception is thrown from within a Future, you can
      catch it with <phrase
      role="keep-together"><literal>catchError()</literal>.</phrase> Be sure
      to invoke <literal>catchError()</literal> on the result of
      <literal>then()</literal>—not on the result of the original
      Future.</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/futures.dart</remark>Future runSearch() {
var future = longExpensiveSearch(); // Returns immediately.

return future.then((results) {
  print('Here are the results: $results');
}).catchError((e) {
  print("Oops! Encountered $e");
});
}</screen>

      <para>The <literal>then().catchError()</literal> pattern is the
      asynchronous version of
      <literal>try</literal>-<literal>catch</literal>.</para>
    </sect2>

    <sect2 id="ch03-chaining-multiple-async-methods">
      <title>Chaining Multiple Asynchronous Methods</title>

      <para>The <literal>then()</literal> method returns a Future, which is a
      useful way to chain multiple asynchronous methods to run in a certain
      order. If the callback registered with <literal>then()</literal> returns
      a Future, then it is simply returned as is by <literal>then()</literal>.
      If the callback returns a value of any other type, a new Future instance
      is created and is completed with the value.</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/futures.dart</remark>Future runQuery() {
Future result = costlyQuery();

return result.then((value) =&gt; expensiveWork())
             .then((value) =&gt; lengthyComputation())
             .then((value) =&gt; print('done!'))
             .catchError((exception) =&gt; print('DOH!'));
}</screen>

      <para>In the above example, the methods run in the following
      order:</para>

      <orderedlist continuation="restarts" inheritnum="ignore"
                   numeration="arabic">
        <listitem>
          <para><literal>costlyQuery()</literal></para>
        </listitem>

        <listitem>
          <para><literal>expensiveWork()</literal></para>
        </listitem>

        <listitem>
          <para><literal>lengthyComputation()</literal></para>
        </listitem>
      </orderedlist>
    </sect2>

    <sect2 id="ch03-waiting-for-multiple-futures">
      <title>Waiting for Multiple Futures</title>

      <para>Sometimes your algorithm needs to initiate many asynchronous
      methods and wait for each one to complete before continuing. Use the
      <ulink
      url="http://api.dartlang.org/dart_async/Future.html#wait"><literal>Future.wait()</literal></ulink>
      static method to manage multiple Futures and wait for them all to
      complete:</para>

      <screen format="linespecific"><remark>lang-dart
</remark>Future deleteDone = deleteLotsOfFiles();
Future copyDone = copyLotsOfFiles();
Future checksumDone = checksumLotsOfOtherFiles();

new Future.wait([deleteDone, copyDone, checksumDone]).then((List values) {
  print('Done with all the long steps');
});</screen>
    </sect2>

    <sect2 id="ch03-more-information-9">
      <title>More Information</title>

      <para>For examples of using Future, see <xref
      linkend="ch03-dartio---file-and-socket-io-for-command-line-apps" />.</para>
    </sect2>
  </sect1>

  <sect1 id="ch03-dart-math">
    <title>dart:math - Math and Random</title>

    <para>The Math library provides common functionality such as sine and
    cosine, maximum and minimum, and constants such as <emphasis>pi</emphasis>
    and <emphasis>e</emphasis>. Most of the functionality in the Math library
    is implemented as top-level functions.</para>

    <para>To use the Math library in your app, import <literal
    moreinfo="none">dart:math</literal>. The following examples use the prefix
    <literal moreinfo="none">math</literal> to make clear which top-level
    functions and constants are from the Math library:</para>

    <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>import 'dart:math' as math;</screen>

    <sect2 id="ch03-trigonometry">
      <title>Trigonometry</title>

      <para>The Math library provides basic trigonometric functions:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>// Cosine
assert(math.cos(math.PI) == -1.0);

// Sine
var degrees = 30;
var radians = degrees * (math.PI / 180);
// radians is now 0.52359.
var sinOf30degrees = math.sin(radians);

// Truncate the decimal places to 2.
assert(double.parse(sinOf30degrees.toStringAsPrecision(2)) == 0.5);</screen>

      <note>
        <para>These functions use radians, not degrees!</para>
      </note>
    </sect2>

    <sect2 id="ch03-maximum-and-minimum">
      <title>Maximum and Minimum</title>

      <para>The Math library provides optimized <literal>max()</literal> and
      <literal>min()</literal> methods:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>assert(math.max(1, 1000) == 1000);
assert(math.min(1, -1000) == -1000);</screen>
    </sect2>

    <sect2 id="ch03-math-constants">
      <title>Math Constants</title>

      <para>Find your favorite constants—<emphasis>pi</emphasis>,
      <emphasis>e</emphasis>, and more—in the Math library:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>// See the Math library for additional constants.
print(math.E);     // 2.718281828459045
print(math.PI);    // 3.141592653589793
print(math.SQRT2); // 1.4142135623730951</screen>
    </sect2>

    <sect2 id="ch03-random-numbers">
      <title>Random Numbers</title>

      <para>Generate random numbers with the <ulink
      url="http://api.dartlang.org/dart_math/Random.html">Random</ulink>
      class. You can optionally provide a seed to the Random
      constructor.</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>var random = new math.Random();
random.nextDouble(); // Between 0.0 and 1.0: [0, 1)
random.nextInt(10);  // Between 0 and 9.</screen>

      <para>You can even generate random booleans:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/math-tests.dart
</remark>var random = new math.Random();
random.nextBool();  // true or false</screen>
    </sect2>

    <sect2 id="ch03-more-information-7">
      <title>More Information</title>

      <para>Refer to the <ulink
      url="http://api.dartlang.org/dart_math/index.html">Math API docs</ulink>
      for a full list of methods. Also see the API docs for<phrase
      role="keep-together"> <ulink
      url="http://api.dartlang.org/dart_core/num.html">num,</ulink></phrase>
      <ulink url="http://api.dartlang.org/dart_core/int.html">int,</ulink> and
      <ulink
      url="http://api.dartlang.org/dart_core/double.html">double.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch03-dart-html-using-html5-apis">
    <title>dart:html - Browser-Based Apps</title>

    <para>Use the <ulink
    url="http://api.dartlang.org/dart_html.html">dart:html library</ulink> to
    program the browser, manipulate objects and elements in the DOM, and
    access HTML5 APIs. <firstterm>DOM</firstterm> stands for
    <emphasis>Document Object Model</emphasis>, which describes the hierarchy
    of an HTML page.</para>

    <para>Other common uses of dart:html are manipulating styles
    (<emphasis>CSS</emphasis>), getting data using HTTP requests, and
    exchanging data using <link linkend="ch03-websockets">WebSockets</link>.
    HTML5 (and dart:html) has many additional APIs that this section doesn’t
    cover. Only web apps can use dart:html, not command-line apps.</para>

    <note>
      <para>For a scalable, higher level approach to web app UIs, see the
      <ulink url="http://www.dartlang.org/articles/web-ui/">Web UI
      package.</ulink></para>
    </note>

    <para>To use the HTML library in your web app, import <literal
    moreinfo="none">dart:html</literal>:</para>

    <programlisting format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>import 'dart:html';</programlisting>

    <sect2 id="ch03-manipulating-the-dom">
      <title>Manipulating the DOM</title>

      <para>To use the DOM, you need to know about
      <emphasis>windows</emphasis>, <emphasis>documents</emphasis>,
      <emphasis>elements</emphasis>, and <emphasis>nodes</emphasis>.</para>

      <para>A <ulink
      url="http://api.dartlang.org/html/Window.html">Window</ulink> object
      represents the actual window of the web browser. Each Window has a
      <literal moreinfo="none">document</literal> property (a Document
      object), which points to the document currently loaded. The Window
      object also has accessors to various APIs such as IndexedDB (for storing
      data), <literal>requestAnimationFrame()</literal> (for animations), and
      more. In tabbed browsers, each tab has its own Window object.</para>

      <para>With the <ulink url="http://api.dartlang.org/html/Document.html">
      Document</ulink> object, you can create and manipulate <ulink
      url="http://api.dartlang.org/html/Element.html">Elements</ulink> within
      the document. Note that the document itself is an element and can be
      manipulated.</para>

      <para>The DOM models a tree of <ulink
      url="http://api.dartlang.org/html/Node.html">Nodes.</ulink> These nodes
      are often elements, but they can also be attributes, text, comments, and
      other DOM types. Except for the root node, which has no parent, each
      node in the DOM has one parent and might have many children.</para>

      <sect3 id="ch03-finding-elements">
        <title>Finding elements</title>

        <para>To manipulate an element, you first need an object that
        represents it. You can get this object using a query.</para>

        <para>Find one or more elements using the top-level functions
        <literal>query()</literal> and<literal> queryAll()</literal>. You can
        query by ID, class, tag, name, or any combination of these. The <ulink
        url="http://www.w3.org/TR/css3-selectors/">CSS Selector Specification
        guide</ulink> defines the formats of the selectors such as using a #
        prefix to specify IDs and a period (.) for classes.</para>

        <para>The query() function returns the first element that matches the
        selector, while <phrase
        role="keep-together"><literal>queryAll()</literal> </phrase>returns a
        collection of elements that match the selector.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>Element elem1 = query('#an-id');           // Find an element by id (an-id).
Element elem2 = query('.a-class');         // Find an element by class (a-class).
List&lt;Element&gt; elems1 = queryAll('div');    // Find all elements by tag (&lt;div&gt;).
List&lt;Element&gt; elems2 = queryAll('input[type="text"]'); // Find all text inputs.

// Find all elements with the CSS class 'class' inside of a &lt;p&gt;
// that is inside an element with the ID 'id'.
List&lt;Element&gt; elems3 = queryAll('#id p.class');</screen>
      </sect3>

      <sect3 id="ch03-manipulating-elements">
        <title>Manipulating elements</title>

        <para>You can use properties to change the state of an element. Node
        and its subtype Element define the properties that all elements have.
        For example, all elements have <literal
        moreinfo="none">classes</literal>, <literal
        moreinfo="none">hidden</literal>, <literal
        moreinfo="none">id</literal>, <literal
        moreinfo="none">innerHtml</literal>, <literal
        moreinfo="none">style</literal>, <literal
        moreinfo="none">text</literal>, and <literal
        moreinfo="none">title</literal> properties. Subclasses of Element
        define additional properties, such as the <literal
        moreinfo="none">href</literal> property of <ulink
        url="http://api.dartlang.org/html/AnchorElement.html">AnchorElement.</ulink></para>

        <para>Consider this example of specifying an anchor element in
        HTML:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>&lt;a id="example" href="http://example.com"&gt;link text&lt;/a&gt;</screen>

        <para>This &lt;a&gt; tag specifies an element with an <literal
        moreinfo="none">href</literal> attribute and a text node (accessible
        via a <literal moreinfo="none">text</literal> property) that contains
        the string “linktext”. To change the URL that the link goes to, you
        can use AnchorElement’s <literal moreinfo="none">href</literal>
        property:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>query('#example').href = 'http://dartlang.org';</screen>

        <para>Often you need to set properties on multiple elements. For
        example, the following code sets the <literal
        moreinfo="none">hidden</literal> property of all elements that have a
        class of “mac”, “win”, or “linux”. Setting the <literal
        moreinfo="none">hidden</literal> property to true has the same effect
        as adding <literal moreinfo="none">display:none</literal> to <phrase
        role="keep-together">the CSS</phrase>.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>&lt;!-- In HTML: --&gt;
&lt;p&gt;
  &lt;span class="os linux"&gt;Words for Linux&lt;/span&gt;
  &lt;span class="os mac"&gt;Words for Mac&lt;/span&gt;
  &lt;span class="os win"&gt;Words for Windows&lt;/span&gt;
&lt;/p&gt;
<remark>
</remark>// In Dart:
final osList = ['mac', 'win', 'linux'];

var userOs = 'linux'; // In real code you'd programmatically determine this.

for (var os in osList) {            // For each possible OS...
  bool shouldShow = (os == userOs); // Does this OS match the user's OS?
  for (var elem in queryAll('.$os')) { // Find all elements for this OS.
    elem.hidden = !shouldShow;      // Show or hide each element.
  }
}</screen>

        <para>When the right property isn’t available or convenient, you can
        use Element’s <literal moreinfo="none">attributes</literal> property.
        This property has the type <ulink
        url="http://api.dartlang.org/html/AttributeMap.html">AttributeMap,</ulink>
        which implements a <link
        linkend="ch03-maps-aka-dictionaries-or-hashes">map</link> with keys
        that are strings (attribute names) and values that it automatically
        converts to strings. For a list of attribute names and their meanings,
        see the <ulink url="https://developer.mozilla.org/en/HTML/Attributes">
        MDN Attributes page.</ulink> Here’s an example of setting an
        attribute’s value:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>elem.attributes['someAttribute'] = 'someValue';</screen>
      </sect3>

      <sect3 id="ch03-creating-elements">
        <title>Creating elements</title>

        <para>You can add to existing HTML pages by creating new elements and
        attaching them to the DOM. Here’s an example of creating a paragraph
        (&lt;p&gt;) element:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var elem = new ParagraphElement();
elem.text = 'Creating is easy!';</screen>

        <para>You can also create an element by parsing HTML text. Any child
        elements are also parsed and created.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var elem2 = new Element.html('&lt;p&gt;Creating &lt;em&gt;is&lt;/em&gt; easy!&lt;/p&gt;');</screen>

        <para>Note that elem2 is a ParagraphElement in the above
        example.</para>

        <para>Attach the newly created element to the document by assigning a
        parent to the element. You can add an element to any existing
        element’s children. In the following example, <literal
        moreinfo="none">body</literal> is an element, and its child elements
        are accessible (as a List&lt;Element&gt;) from the <literal
        moreinfo="none">children</literal> property.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>document.body.children.add(elem2);</screen>
      </sect3>

      <sect3 id="ch03-adding-replacing-and-removing-nodes">
        <title>Adding, replacing, and removing nodes</title>

        <para>Recall that elements are just a kind of node. You can find all
        the children of a node using the <literal
        moreinfo="none">nodes</literal> property of Node, which returns a
        List&lt;Node&gt;. Once you have this list, you can use the usual List
        methods and operators to manipulate the children of the node.</para>

        <para>To add a node as the last child of its parent, use the List
        <literal>add()</literal> method:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// Find the parent by ID, and add elem as its last child.
query('#inputs').nodes.add(elem);</screen>

        <para>To replace a node, use the Node <literal>replaceWith()</literal>
        method:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// Find a node by ID, and replace it in the DOM.
query('#status').replaceWith(elem);</screen>

        <para>To remove a node, use the Node <literal>remove()</literal>
        method:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// Find a node by ID, and remove it from the DOM.
query('#expendable').remove();</screen>
      </sect3>

      <sect3 id="ch03-manipulating-styles">
        <title>Manipulating CSS styles</title>

        <para>CSS, or <emphasis>cascading style sheets</emphasis>, is used to
        define the presentation styles of DOM elements. You can change the
        appearance of an element by attaching ID and class attributes to
        it.</para>

        <para>Each element has a <literal moreinfo="none">classes</literal>
        field, which is a list. Add and remove CSS classes simply by adding
        and removing strings from this collection. For example, the following
        sample adds the <literal moreinfo="none">warning</literal> class to an
        element:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var element = query('#message');
element.classes.add('warning');</screen>

        <para>It’s often very efficient to find an element by ID. You can
        dynamically set an element ID with the <literal
        moreinfo="none">id</literal> property:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var message = new DivElement();
message.id = 'message2';
message.text = 'Please subscribe to the Dart mailing list.';</screen>

        <para>You can reduce the redundant text in this example by using
        method cascades:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>var message = new DivElement()
    ..id = 'message2'
    ..text = 'Please subscribe to the Dart mailing list.';</screen>

        <para>While using IDs and classes to associate an element with a set
        of styles is best practice, sometimes you want to attach a specific
        style directly to the element:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>message.style
    ..fontWeight = 'bold'
    ..fontSize = '3em';</screen>
      </sect3>

      <sect3 id="ch03-handling-events">
        <title>Handling events</title>

        <para>To respond to external events such as clicks, changes of focus,
        and selections, add an event listener. You can add an event listener
        to any element on the page. Event dispatch and propagation is a
        complicated subject; <ulink
        url="http://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture">research
        the details</ulink> if you’re new to web programming.</para>

        <para>Add an event handler using <literal
        moreinfo="none">element.on<replaceable>Event</replaceable>.listen(<replaceable>function</replaceable>)</literal>,
        where <literal
        moreinfo="none"><replaceable>Event</replaceable></literal> is the
        event name and <literal
        moreinfo="none"><replaceable>function</replaceable></literal> is the
        event handler.</para>

        <para>For example, here’s how you can handle clicks on a
        button:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>// Find a button by ID and add an event handler.
query('#submitInfo').onClick.listen((e) {
  // When the button is clicked, it runs this code.
  submitData();
});</screen>

        <para>Events can propagate up and down through the DOM tree. To
        discover which element originally fired the event, use <literal
        moreinfo="none">e.target</literal>:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_html.dart
</remark>document.body.onClick.listen((e) {
  var clickedElem = e.target;
  print('You clicked the ${clickedElem.id} element.');
});</screen>

        <para>To see all the events for which you can register an event
        listener, consult the API docs for <ulink
        url="http://api.dartlang.org/html/ElementEvents.html">ElementEvents</ulink>
        and its subclasses. Some common events include:</para>

        <itemizedlist>
          <listitem>
            <para>change</para>
          </listitem>

          <listitem>
            <para>blur</para>
          </listitem>

          <listitem>
            <para>keyDown</para>
          </listitem>

          <listitem>
            <para>keyUp</para>
          </listitem>

          <listitem>
            <para>mouseDown</para>
          </listitem>

          <listitem>
            <para>mouseUp</para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>

    <sect2 id="ch03-httprequest">
      <title>Using HTTP Resources with HttpRequest</title>

      <para>Formerly known as XMLHttpRequest, the <emphasis><ulink
      url="http://api.dartlang.org/dart_html/HttpRequest.html">HttpRequest</ulink></emphasis>
      class gives you access to HTTP resources from within your browser-based
      app. Traditionally, AJAX-style apps make heavy use of HttpRequest. Use
      HttpRequest to dynamically load JSON data or any other resource from a
      web server. You can also dynamically send data to a web server.</para>

      <para>The following examples assume all resources are served from the
      same web server that hosts the script itself. Due to security
      restrictions in the browser, the HttpRequest class can’t easily use
      resources that are hosted on an origin that is different from the origin
      of the app. If you need to access resources that live on a different web
      server, you need to either use a technique called JSONP or enable CORS
      headers on the remote resources.</para>

      <sect3 id="_getting_data_from_the_server">
        <title>Getting data from the server</title>

        <para>The HttpRequest static method <literal>getString()</literal> is
        an easy way to get data from a web server. Use
        <literal>then()</literal> after <literal>getString()</literal> to
        specify the function that handles the string data.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_2_html.dart
</remark>import 'dart:html';
import 'dart:async';

// A JSON-formatted file in the same location as this page.
var uri = 'data.json';

main() {
  // Read a JSON file.
  HttpRequest.getString(uri).then(processString);
}

processString(String jsonText) {
  parseText(jsonText);
}</screen>

        <para>The function you specify (in the example,
        <literal>processString()</literal>) runs when the data at the
        specified URI is successfully retrieved. In this case, we are
        dynamically loading a JSON file. Information about the JSON API is in
        <xref linkend="ch03-json" />.</para>

        <para>Add <literal>.catchError()</literal> after the call to
        <literal>.then()</literal> to specify an error handler:</para>

        <programlisting role="keep-together"><remark>lang-dart
</remark><remark>ch03_html/ch03_2_html.dart
</remark>...
HttpRequest.getString(uri)
    .then(processString)
    .catchError(handleError);
...
handleError(error) {
  print('Uh oh, there was an error.');
  print(error.toString());
}</programlisting>

        <para>If you need access to the HttpRequest, not just the text data it
        retrieves, you can use the <literal>request()</literal> static method
        instead of <literal>getString()</literal>. Here’s an example of
        reading XML data:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03_html/ch03_2_html.dart
</remark>import 'dart:html';
import 'dart:async';

// An XML-formatted file in the same location as this page.
var xmlUri = 'data.xml';

main() {
  // Read an XML file.
  HttpRequest.request(uri)
      .then(processRequest)
      .catchError(handleError);
}

processRequest(HttpRequest request) {
  var xmlDoc = request.responseXml;
  try {
    var license = xmlDoc.query('license').text;
    print('License: $license');
  } catch(e) {
    print('$xmlUri doesn\'t have correct XML formatting.');
  }
}
...</screen>

        <para>You can also use the full API to handle more interesting cases.
        For example, you can set arbitrary headers.</para>

        <para>The general flow for using the full API of HttpRequest is as
        follows:</para>

        <orderedlist continuation="restarts" inheritnum="ignore"
                     numeration="arabic">
          <listitem>
            <para>Create the HttpRequest object.</para>
          </listitem>

          <listitem>
            <para>Open the URL with either <literal
            moreinfo="none">GET</literal> or <literal
            moreinfo="none">POST</literal>.</para>
          </listitem>

          <listitem>
            <para>Attach event handlers.</para>
          </listitem>

          <listitem>
            <para>Send the request.</para>
          </listitem>
        </orderedlist>

        <para>For example:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>tutorial/servers/web/client.dart
</remark>import 'dart:html';
...
var httpRequest = new HttpRequest();
httpRequest.open('POST', dataUrl);
httpRequest.onLoadEnd.listen((e) =&gt; loadEnd(httpRequest));
httpRequest.send(encodedData);
</screen>
      </sect3>

      <sect3 id="_sending_data_to_the_server">
        <title>Sending data to the server</title>

        <para>HttpRequest can send data to the server using the HTTP method
        POST. For example, you might want to dynamically submit data to a form
        handler. Sending JSON data to a RESTful web service is another common
        example.</para>

        <para>Submitting data to a form handler requires you to provide
        name-value pairs as URI-encoded strings. (Information about the URI
        API is in <xref linkend="ch03-uri" />.) You must also set the <literal
        moreinfo="none">Content-type</literal> header to <literal
        moreinfo="none">application/x-www-form-urlencode</literal> if you wish
        to send data to a form handler.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/ch03_3_html/*
</remark>import 'dart:html';
import 'dart:uri';
...
String encodeMap(Map data) {
  return data.keys.map((k) {
    return '${encodeUriComponent(k)}=${encodeUriComponent(data[k])}';
  }).join('&amp;');
}

loadEnd(HttpRequest request) {
  if (request.status != 200) {
    print('Uh oh, there was an error of ${request.status}');
  } else {
    print('Data has been posted');
  }
}

main() {
  var dataUrl = '/registrations/create';
  var data = {'dart': 'fun', 'editor': 'productive'};
  var encodedData = encodeMap(data);

  var httpRequest = new HttpRequest();
  httpRequest.open('POST', dataUrl);
  httpRequest.setRequestHeader('Content-type', 
                               'application/x-www-form-urlencoded');
  httpRequest.onLoadEnd.listen((e) =&gt; loadEnd(httpRequest));
  httpRequest.send(encodedData);
}</screen>
      </sect3>
    </sect2>

    <sect2 id="ch03-websockets">
      <title>Sending and Receiving Real-Time Data with WebSockets</title>

      <para>A WebSocket allows your web app to exchange data with a server
      interactively—no polling necessary. A server creates the WebSocket and
      listens for requests on a URL that starts with <emphasis
      role="strong">ws://</emphasis>—for example, ws://127.0.0.1:1337/ws. The
      data transmitted over a WebSocket can be a string, a blob, or an <ulink
      url="http://api.dartlang.org/html/ArrayBuffer.html">ArrayBuffer.</ulink>
      Often, the data is a JSON-formatted string.</para>

      <para>To use a WebSocket in your web app, first create a <ulink
      url="http://api.dartlang.org/html/WebSocket.html">WebSocket</ulink>
      object, passing the WebSocket URL as an argument:</para>

      <screen format="linespecific"><remark>lang-dart
</remark>var webSocket = new WebSocket('ws://127.0.0.1:1337/ws');</screen>

      <sect3 id="ch03-sending-data">
        <title>Sending data</title>

        <para>To send string data on the WebSocket, use the
        <literal>send()</literal> method:</para>

        <screen format="linespecific"><remark>lang-dart
</remark>sendMessage(String data) {
  if (webSocket.readyState == WebSocket.OPEN) {
    webSocket.send(data);
  } else {
    throw 'WebSocket not connected, message $data not sent';
  }
}</screen>
      </sect3>

      <sect3 id="ch03-receiving-data">
        <title>Receiving data</title>

        <para>To receive data on the WebSocket, register a listener for
        message events:</para>

        <screen format="linespecific"><remark>lang-dart
</remark>webSocket.onMessage.listen((MessageEvent e) {
  receivedMessage(e.data);
});</screen>

        <para>The message event handler receives a <ulink
        url="http://api.dartlang.org/html/MessageEvent.html">MessageEvent</ulink>
        object. This object’s <literal moreinfo="none">data</literal> field
        has the data from the server. Here’s an example of decoding a JSON
        string sent on a WebSocket, where the JSON string has two fields,
        “from” and “content”:</para>

        <screen format="linespecific"><remark>lang-dart
</remark>// Called from the message listener like this: receivedMessage(e.data)
receivedMessage(String data) {
  Map message = json.parse(data);
  if (message['from'] != null) {
    print('Message from ${message['from']}: ${message['content']}');
  }
}</screen>
      </sect3>

      <sect3 id="ch03-handling-websocket-events">
        <title>Handling WebSocket events</title>

        <para><ulink
        url="http://api.dartlang.org/html/WebSocketEvents.html">WebSocketEvents</ulink>
        defines the WebSocket events your app can handle: open, close, error,
        and (as shown above) message. Here’s an example of a method that
        creates a WebSocket object and handles message, open, close, and error
        events:</para>

        <screen format="linespecific"><remark>lang-dart
</remark>connectToWebSocket([int retrySeconds = 2]) {
  bool reconnectScheduled = false;
  webSocket = new WebSocket(url);
  
  scheduleReconnect() {
    print('web socket closed, retrying in $retrySeconds seconds');
    if (!reconnectScheduled) {
      new Timer(new Duration(seconds:retrySeconds),
        () =&gt; connectToWebSocket(retrySeconds*2));
    }
    reconnectScheduled = true;
  }
  
  webSocket.onOpen.listen((e) {
    print('Connected');
  });
  
  webSocket.onClose.listen((e) =&gt; scheduleReconnect());
  webSocket.onError.listen((e) =&gt; scheduleReconnect());
  
  webSocket.onMessage.listen((MessageEvent e) {
    _receivedEncodedMessage(e.data);
  });
}</screen>

        <para>For an example of using WebSockets, see <xref lang=""
        linkend="ch05" />.</para>
      </sect3>
    </sect2>

    <sect2 id="ch03-more-information-html">
      <title>More information</title>

      <para>This section barely scratched the surface of using the dart:html
      library. For more information, see the documentation for <ulink
      url="http://api.dartlang.org/dart_html.html">dart:html.</ulink> Dart has
      additional libraries for more specialized web APIs, such as <ulink
      url="http://api.dartlang.org/dart_web_audio.html">web audio.</ulink>
      Finally, don’t miss the <ulink
      url="http://www.dartlang.org/articles/web-ui/">Web UI
      package.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch03-dartisolate---concurrency-with-isolates">
    <title>dart:isolate - Concurrency with Isolates</title>

    <para>Dart has no shared-memory threads. Instead, all Dart code runs in
    isolates, which communicate via message passing. Messages are copied
    before they are received, ensuring that no two isolates can manipulate the
    same object instance. Because state is managed by individual isolates, no
    locks or mutexes are needed, greatly simplifying concurrent
    programming.</para>

    <sect2 id="ch03-isolate-concepts">
      <title>Isolate Concepts</title>

      <para>To use isolates, you should understand the following
      concepts:</para>

      <itemizedlist>
        <listitem>
          <para>No two isolates ever share the same thread at the same time.
          Within an isolate, callbacks execute one at a time, making the code
          more predictable.</para>
        </listitem>

        <listitem>
          <para>All values in memory, including globals, are available only to
          their isolate. No isolate can see or manipulate values owned by
          another isolate.</para>
        </listitem>

        <listitem>
          <para>The only way isolates can communicate with each other is by
          passing messages.</para>
        </listitem>

        <listitem>
          <para>Isolates send messages using SendPorts, and receive them using
          ReceivePorts.</para>
        </listitem>

        <listitem>
          <para>The content of a message can be any of the following:</para>

          <itemizedlist>
            <listitem>
              <para>A primitive value (null, num, bool, double, String)</para>
            </listitem>

            <listitem>
              <para>An instance of SendPort</para>
            </listitem>

            <listitem>
              <para>A list or map whose elements are any of the above,
              including other lists and maps</para>
            </listitem>

            <listitem>
              <para>In <link linkend="ch03-sending-any-type-of-object">special
              circumstances</link>, an object of any type</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Each isolate has a ReceivePort, which is available as the
          <literal moreinfo="none">port</literal> variable. Because all Dart
          code runs inside an isolate, even <literal>main()</literal> has
          access to a port object.</para>
        </listitem>

        <listitem>
          <para>When a web application is compiled to JavaScript, its isolates
          can be implemented as Web workers. When running in Dartium, isolates
          run in the VM.</para>
        </listitem>

        <listitem>
          <para>In the standalone VM, the <literal>main()</literal> function
          runs in the first isolate (also known as the <emphasis>root
          isolate</emphasis>). When the root isolate terminates, it terminates
          the whole VM, regardless of whether other isolates are still
          running. For more information, see <xref
          linkend="ch03-keeping-the-root-isolate-alive" />.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="ch03-using-isolates">
      <title>Using Isolates</title>

      <para>To use an isolate, you import the <literal
      moreinfo="none">dart:isolate</literal> library, spawn a new isolate, and
      then send and receive messages.</para>

      <sect3 id="ch03-spawning-isolates">
        <title>Spawning isolates</title>

        <para>Any top-level function or static method<footnote
            id="ch03-isolate-footnote-1">
            <para>The dart2js compiler and the Dart VM do not yet support
            static methods as isolate entry points. For details, see <ulink
            url="http://dartbug.com/3011"></ulink>.</para>
          </footnote> is a valid entry point for an isolate. The entry point
        should not expect arguments and should return void. It is illegal to
        use a function closure as an entry point to an isolate. Pass the entry
        point to <literal>spawnFunction()</literal>.</para>

        <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:isolate';

runInIsolate() {
  print('hello from an isolate!');
}

main() {
  spawnFunction(runInIsolate);

  // Note: incomplete.
  // Use a ReceivePort (details below) to keep the root isolate alive
  // long enough for runInIsolate() to perform its work.
}</screen>

        <para>We plan to support spawning an isolate from code at a
        URI.</para>
      </sect3>

      <sect3 id="ch03-sending-messages">
        <title>Sending messages</title>

        <para>Send a message to an isolate via a SendPort. The
        <literal>spawnFunction()</literal> method returns a handle to the
        newly created isolate’s SendPort.</para>

        <para>To simply send a message, use <literal>send()</literal>:</para>

        <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:isolate';

echo() {
  // Receive messages here. (See the next section.)
}

main() {
  var sendPort = spawnFunction(echo);
  sendPort.send('Hello from main');

  // Note: incomplete.
  // Use a ReceivePort (details below) to keep the root isolate alive
  // long enough for echo() to perform its work.
}</screen>
      </sect3>

      <sect3 id="ch03-sending-any-type-of-object">
        <title>Sending any type of object</title>

        <para>In special circumstances (such as when using
        <literal>spawnFunction()</literal> inside the Dart VM), it is possible
        to send any type of object to an isolate.<footnote
            id="ch03-isolate-footnote-2">
            <para>Support for sending an arbitrary object to an isolate is not
            yet available when compiling to JavaScript.</para>
          </footnote> The object message is copied when sent.</para>
      </sect3>

      <sect3 id="ch03-receiving-messages">
        <title>Receiving messages</title>

        <para>Use a ReceivePort to receive messages sent to an isolate. Obtain
        a handle to the default ReceivePort from the top-level <literal
        moreinfo="none">port</literal> property. You can also create new
        instances of ReceivePort, if you want to route messages to different
        ports and callbacks.</para>

        <para>Handle an incoming message with a callback function passed to
        the <literal>receive()</literal> method:</para>

        <programlisting role="keep-together"><remark>lang-dart
</remark>import 'dart:isolate';
echo() {
  port.receive((msg, reply) {
    print('I received: $msg');
  });
}

main() {
  var sendPort = spawnFunction(echo);
  sendPort.send('Hello from main');

  // Note: incomplete.
  // Use a ReceivePort (details below) to keep the root isolate alive
  // long enough for echo() to perform its work.
}</programlisting>
      </sect3>

      <sect3 id="ch03-receiving-replies">
        <title>Receiving replies</title>

        <para>Use the <literal>call()</literal> method on SendPort as a simple
        way to send a message and receive a reply. The
        <literal>call()</literal> method returns a Future for the
        reply.</para>

        <screen format="linespecific" role=""><remark>lang-dart
</remark>import 'dart:isolate';

echo() {
  port.receive((msg, reply) {
    reply.send('I received: $msg');
  });
}

main() {
  var sendPort = spawnFunction(echo);
  sendPort.call('Hello from main').then((reply) {
    print(reply);    // I received: Hello from main
  });
}</screen>

        <para>Under the covers, the <literal>call()</literal> method creates
        and manages a SendPort and a ReceivePort, which are necessary for a
        call-and-response message exchange.</para>
      </sect3>

      <sect3 id="ch03-keeping-the-root-isolate-alive">
        <title>Keeping the root isolate alive</title>

        <para>In the VM, an isolate continues to run as long as it has an open
        ReceivePort inside the isolate. If the <literal>main()</literal>
        function only starts other isolates, doing no work itself, you must
        keep the root isolate alive to keep the program alive.</para>

        <para>To keep a root isolate alive, open a ReceivePort in the root
        isolate. When all the child isolates have finished their work, you can
        send a message to the root isolate to close its ReceivePort, thus
        stopping the program.</para>

        <para>You can coordinate isolates with message passing, sending a
        message to inform the root isolate when a child isolate finishes. Here
        is an example:</para>

        <screen format="linespecific" role="keep-together"><remark>lang-dart
</remark>import 'dart:isolate';

childIsolate() {
  port.receive((msg, replyTo) {
    print('doing some work');
    if (replyTo != null) replyTo.send('shutdown');
  });
}

main() {
  var sender = spawnFunction(childIsolate);
  var receiver = new ReceivePort();
  receiver.receive((msg, _) {
    if (msg == 'shutdown') {
      print('shutting down');
      receiver.close();
    }
  });
  sender.send('do work please', receiver.toSendPort());
}</screen>

        <para>In the above example, the child isolate runs to completion
        because the root isolate keeps a ReceivePort open. The root isolate
        creates a ReceivePort to wait for a shutdown message. The term
        shutdown is arbitrary; the ReceivePort simply needs to wait for some
        signal.</para>

        <para>Once the root isolate receives a shutdown message, it closes the
        ReceivePort. With the ReceivePort closed and nothing else to do, the
        root isolate terminates, causing the app to exit.</para>
      </sect3>
    </sect2>

    <sect2 id="ch03-more-information-11">
      <title>More Information</title>

      <para>See the API docs for the <ulink
      url="http://api.dartlang.org/dart_isolate.html">dart:isolate
      library,</ulink> as well as for <ulink
      url="http://api.dartlang.org/dart_isolate/SendPort.html">SendPort</ulink>
      and <ulink role="keep-together" security=""
      url="http://api.dartlang.org/dart_isolate/ReceivePort.html">ReceivePort</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="ch03-dartio---file-and-socket-io-for-command-line-apps">
    <title>dart:io - I/O for Command-Line Apps</title>

    <para>The <ulink url="http://api.dartlang.org/io.html">dart:io
    library</ulink> provides APIs to deal with files, directories, processes,
    sockets, and HTTP connections. Only command-line apps can use dart:io—not
    web apps.</para>

    <para>In general, the dart:io library implements and promotes an
    asynchronous API. Synchronous methods can easily block the event loop,
    making it difficult to scale server applications. Therefore, most
    operations return results via callbacks or Future objects, a pattern
    common with modern server platforms such as Node.js.</para>

    <para>The few synchronous methods in the dart:io library are clearly
    marked with a Sync suffix on the method name. We don’t cover them
    here.</para>

    <note>
      <para>Only command-line apps can import and use <literal
      moreinfo="none">dart:io</literal>.</para>
    </note>

    <sect2 id="ch03-files-and-directories">
      <title>Files and Directories</title>

      <para>The I/O library enables command-line apps to read and write files
      and browse directories. You have two choices for reading the contents of
      a file: all at once, or streaming. Reading a file all at once requires
      enough memory to store all the contents of the file. If the file is very
      large or you want to process it while reading it, you should use an
      Stream, as described in <xref
      linkend="ch03-streaming-file-contents" />.</para>

      <sect3 id="ch03-reading-a-file-as-text">
        <title>Reading a file as text</title>

        <para>When reading a text file, you can read the entire file contents
        with <literal>readAsString()</literal>. When the individual lines are
        important, you can use <literal>readAsLines()</literal>. In both
        cases, a Future object is returned that provides the contents of the
        file as one or more strings.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/textRead.dart
</remark>import 'dart:io';

main() {
  var config = new File('config.txt');

  // Put the whole file in a single string.
  config.readAsString().then((String contents) {
    print('The entire file is ${contents.length} characters long');
  });

  // Put each line of the file into its own string.
  config.readAsLines().then((List&lt;String&gt; lines) {
    print('The entire file is ${lines.length} lines long');
  });
}</screen>
      </sect3>

      <sect3 id="ch03-reading-a-file-as-binary">
        <title>Reading a file as binary</title>

        <para>The following code reads an entire file as bytes into a list of
        ints. The call to <phrase
        role="keep-together"><literal>readAsBytes()</literal></phrase> returns
        a Future, which provides the result when it’s available.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/binaryRead.dart
</remark>import 'dart:io';

main() {
  var config = new File('config.txt');

  config.readAsBytes().then((List&lt;int&gt; contents) {
    print('The entire file is ${contents.length} bytes long');
  });
}</screen>
      </sect3>

      <sect3 id="ch03-handling-errors">
        <title>Handling errors</title>

        <para>Errors are thrown as exceptions if you do not register an
        explicit handler. If you want to capture an error, you can register a
        <literal moreinfo="none">catchError</literal> handler with the Future
        object:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/fileErrors.dart
</remark>import 'dart:io';

main() {
  var config = new File('config.txt');
  config.readAsString().then((String contents) {
    print(contents);
  }).catchError((e) {
    print(e);
  });
}</screen>
      </sect3>

      <sect3 id="ch03-streaming-file-contents">
        <title>Streaming file contents</title>

        <para>Use a Stream to read a file, a little at a time. The <literal
        moreinfo="none">listen()</literal> method specifies a handler to be
        called when data is available. When the Stream is finished reading the
        file, the <literal moreinfo="none">onDone</literal> callback
        executes.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/readFile.dart
</remark>import 'dart:io';
import 'dart:async';

main() {
  var config = new File('config.txt');
  Stream&lt;List&lt;int&gt;&gt; inputStream = config.openRead();

  inputStream
    .transform(new StringDecoder())
    .transform(new LineTransformer())
    .listen(
      (String line) { 
        print('Read ${line.length} bytes from stream');
      },
      onDone: () { print('file is now closed'); },
      onError: (e) { print(e.toString()); });
}</screen>

        <para>To decode from bytes into characters, wrap the stream with a
        <ulink
        url="http://api.dartlang.org/dart_io/StringDecoder.html">StringDecoder.</ulink>
        You can read the strings either as data becomes available or one line
        at a time.</para>
      </sect3>

      <sect3 id="ch03-writing-file-contents">
        <title>Writing file contents</title>

        <para>You can use an <ulink
        url="http://api.dartlang.org/dart_io/IOSink.html">IOSink</ulink> to
        write data to a file. Use the File <literal>openWrite()</literal>
        method to declare a mode and get an IOSink that you can write to. The
        default mode, <literal moreinfo="none">FileMode.WRITE</literal>,
        completely overwrites existing data in the file.</para>

        <programlisting role="keep-together"><remark>lang-dart
</remark><remark>ch03/writeFile.dart
</remark>var logFile = new File('log.txt');
var sink = logFile.openWrite();
sink.write('FILE ACCESSED ${new DateTime.now()}\n');
sink.close();</programlisting>

        <para>To add to the end of the file, use the optional
        <literal>mode</literal> parameter to specify
        <literal>FileMode.APPEND</literal>:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/writeFile.dart
</remark>var sink = logFile.openWrite(mode: FileMode.APPEND); </screen>

        <para>To write binary data, use <literal
        moreinfo="none">add(List&lt;int&gt; buffer)</literal>.</para>
      </sect3>

      <sect3 id="ch03-listing-files-in-a-directory">
        <title>Listing files in a directory</title>

        <para>Finding all files and subdirectories for a directory is an
        asynchronous operation. The <literal>list()</literal> method returns a
        Stream on which you can register handlers (using
        <literal>listen()</literal>) to be notified when a file or directory
        is encountered.</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/listFiles.dart
</remark>import 'dart:io';
import 'dart:async';

main() {
  var dir = new Directory('/tmp');
  var contentsStream = dir.list(recursive:true);
  contentsStream.listen(
    (FileSystemEntity f) {
      if (f is File) {
        print('Found file ${f.path}');
      } else if (f is Directory) {
        print('Found dir ${f.path}');
      }
    },
    onError: (e) { print(e.toString()); }
  );
}</screen>
      </sect3>

      <sect3 id="ch03-other-common-functionality">
        <title>Other common functionality</title>

        <para>The File and Directory classes contain other functionality,
        including but not limited to:</para>

        <itemizedlist role="keep-together">
          <listitem>
            <para>Creating a file or directory: <literal>create()</literal> in
            File and Directory</para>
          </listitem>

          <listitem>
            <para>Deleting a file or directory: <literal>delete()</literal> in
            File and Directory</para>
          </listitem>

          <listitem>
            <para>Getting the length of a file: <literal>length()</literal> in
            File</para>
          </listitem>

          <listitem>
            <para>Getting random access to a file: <literal>open()</literal>
            in File</para>
          </listitem>
        </itemizedlist>

        <para>Refer to the API docs for <ulink
        url="http://api.dartlang.org/io/File.html">File</ulink> and <ulink
        url="http://api.dartlang.org/io/Directory.html">Directory</ulink> for
        a full list of methods.</para>

        <para>Besides the APIs discussed in this section, the dart:io library
        also provides APIs for <ulink
        url="http://api.dartlang.org/io/Process.html">processes,</ulink>
        <ulink url="http://api.dartlang.org/io/Socket.html">sockets,</ulink>
        and <ulink url="http://api.dartlang.org/io/WebSocket.html">web
        sockets.</ulink></para>

        <para>For more examples of using dart:io, see <xref lang=""
        linkend="ch05" />.</para>
      </sect3>
    </sect2>

    <sect2 id="ch03-io-http">
      <title>HTTP Clients and Servers</title>

      <para>The dart:io library provides classes that command-line apps can
      use for accessing HTTP resources, as well as running HTTP
      servers.</para>

      <sect3 id="_http_server">
        <title>HTTP server</title>

        <para>The <ulink
        url="http://api.dartlang.org/dart_io/HttpServer.html">HttpServer</ulink>
        class provides the low-level functionality for building web servers.
        You can match request handlers, set headers, stream data, and
        more.</para>

        <para>The following sample web server can return only simple text
        information. This server listens on port 8888 and address 127.0.0.1
        (localhost), responding to requests for the path <literal
        moreinfo="none">/languages/dart</literal>. All other requests are
        handled by the default request handler, which returns a response code
        of 404 (not found).</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/httpServer.dart
</remark>import 'dart:io';

main() {
  dartHandler(HttpRequest request) {
    print('New request');
    request.response.write('Dart is optionally typed');
    request.response.close();
  };

  HttpServer.bind('127.0.0.1', 8888).then((HttpServer server) {
    server.listen((request) { 
      print("got request");
      if (request.uri.path == '/languages/dart') {
        dartHandler(request);
      } else {
        request.response.write('Not found');
        request.response.statusCode = HttpStatus.NOT_FOUND;
        request.response.close();
      }
    });
  });
}</screen>

        <para>You can see a more comprehensive HTTP server in <xref
        linkend="ch05-server" />.</para>
      </sect3>

      <sect3 id="_http_client">
        <title>HTTP client</title>

        <para>The <ulink
        url="http://api.dartlang.org/dart_io/HttpClient.html">HttpClient</ulink>
        class helps you connect to HTTP resources from your Dart command-line
        or server-side application. You can set headers, use HTTP methods, and
        read and write data. The HttpClient class does not work in
        browser-based apps. When programming in the browser, use the <link
        linkend="ch03-httprequest">HttpRequest class</link>. Here’s an example
        of using HttpClient:</para>

        <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/httpClient.dart
</remark>import 'dart:io';
import 'dart:uri';

main() {
  var url = new Uri('http://127.0.0.1:8888/languages/dart');
  var httpClient = new HttpClient();
  httpClient.getUrl(url)
    .then((HttpClientRequest request) {
      print('have request');
      return request.close();
    })
    .then((HttpClientResponse response) {
      print('have response');
      response.transform(new StringDecoder()).toList().then((data) {
        var body = data.join('');
        print(body);
        httpClient.close();
      });
    });
}</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="ch03-json">
    <title>dart:json - Encoding and Decoding Objects</title>

    <para><ulink url="http://www.json.org/">JSON</ulink> is a simple text
    format for representing structured objects and collections. The <ulink
    url="http://api.dartlang.org/json.html">JSON library</ulink> decodes
    JSON-formatted strings into Dart objects, and encodes objects into
    JSON-formatted strings.</para>

    <para>The Dart JSON library works in both web apps and command-line apps.
    To use the JSON library, import <literal
    moreinfo="none">dart:json</literal>.</para>

    <sect2 id="ch03-json-decoding">
      <title>Decoding JSON</title>

      <para>Decode a JSON-encoded string into a Dart object with
      <literal>json.parse()</literal>:</para>

      <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:json' as json;

main() {
  // NOTE: Be sure to use double quotes ("), not single quotes ('),
  // inside the JSON string. This string is JSON, not Dart.
  var jsonString = '''
  [
    {"score": 40},
    {"score": 80}
  ]
  ''';

  var scores = json.parse(jsonString);
  assert(scores is List);

  var firstScore = scores[0];
  assert(firstScore is Map);
  assert(firstScore['score'] == 40);
}</screen>
    </sect2>

    <sect2 id="ch03-json-encoding">
      <title>Encoding JSON</title>

      <para>Encode a supported Dart object into a JSON-formatted string with
      <literal>json.stringify()</literal>.</para>

      <para>Only objects of type int, double, String, bool, null, List, or Map
      can be encoded into JSON. List and Map objects are encoded
      recursively.</para>

      <para>If any object that isn’t an int, double, String, bool, null, List,
      or Map is passed to <phrase
      role="keep-together"><literal>stringify()</literal>,</phrase> the
      object’s <literal>toJson()</literal> method is called. If
      <literal>toJson()</literal> returns an encodable value, that value is
      encoded in the object’s place.</para>

      <programlisting role="keep-together"><remark>lang-dart
</remark>import 'dart:json' as json;

main() {
  var scores = [
    {'score': 40},
    {'score': 80},
    {'score': 100, 'overtime': true, 'special_guest': null}
  ];

  var jsonText = json.stringify(scores);
  assert(jsonText == '[{"score":40},{"score":80},'
                     '{"score":100,"overtime":true,'
                     '"special_guest":null}]');
}</programlisting>
    </sect2>
  </sect1>

  <sect1 id="ch03-uri">
    <title>dart:uri - Manipulating URIs</title>

    <para>The <ulink url="http://api.dartlang.org/uri.html">URI
    library</ulink> provides functions to encode and decode strings for use in
    URIs (which you might know as <emphasis>URLs</emphasis>). These functions
    handle characters that are special for URIs, such as <literal
    moreinfo="none">&amp;</literal> and <literal
    moreinfo="none">=</literal>.</para>

    <para>Another part of the URI library is the Uri class, which parses and
    exposes the components of a URI—domain, port, scheme, and so on.</para>

    <para>The URI library works in both web apps and command-line apps. To use
    it, import <literal moreinfo="none">dart:uri</literal>.</para>

    <sect2 id="ch03-uri-fully-qualified">
      <title>Encoding and Decoding Fully Qualified URIs</title>

      <para>To encode and decode characters <emphasis>except</emphasis> those
      with special meaning in a URI (such as <literal
      moreinfo="none">/</literal>, <literal moreinfo="none">:</literal>,
      <literal moreinfo="none">&amp;</literal>, <literal
      moreinfo="none">#</literal>), use the top-level
      <literal>encodeUri()</literal> and <literal>decodeUri()</literal>
      functions. These <phrase role="keep-together">functions are
      good</phrase> for encoding or decoding a fully qualified URI, leaving
      intact <phrase role="keep-together">special URI
      characters.</phrase></para>

      <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:uri';

main() {
  var uri = 'http://example.org/api?foo=some message';
  var encoded = encodeUri(uri);
  assert(encoded == 'http://example.org/api?foo=some%20message');

  var decoded = decodeUri(encoded);
  assert(uri == decoded);
}</screen>

      <para>Notice how only the space between <literal
      moreinfo="none">some</literal> and <literal
      moreinfo="none">message</literal> was encoded.</para>
    </sect2>

    <sect2 id="ch03-uri-components">
      <title>Encoding and Decoding URI Components</title>

      <para>To encode and decode all of a string’s characters that have
      special meaning in a URI, including (but not limited to) <literal
      moreinfo="none">/</literal>, <literal moreinfo="none">&amp;</literal>,
      and <literal moreinfo="none">:</literal>, use the top-level
      <literal>encodeUriComponent()</literal> and
      <literal>decodeUriComponent()</literal> functions.</para>

      <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:uri';

main() {
  var uri = 'http://example.org/api?foo=some message';
  var encoded = encodeUriComponent(uri);
  assert(encoded == 'http%3A%2F%2Fexample.org%2Fapi%3Ffoo%3Dsome%20message');

  var decoded = decodeUriComponent(encoded);
  assert(uri == decoded);
}</screen>

      <para>Notice how every special character is encoded. For example,
      <literal moreinfo="none">/</literal> is encoded to <literal
      moreinfo="none">%2F</literal>.</para>
    </sect2>

    <sect2 id="ch03-uri-parsing">
      <title>Parsing URIs</title>

      <para>You can parse a URI into its parts with the
      <literal>Uri()</literal> constructor:</para>

      <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:uri';

main() {
  var uri = new Uri('http://example.org:8080/foo/bar#frag');

  assert(uri.scheme == 'http');
  assert(uri.domain == 'example.org');
  assert(uri.path == '/foo/bar');
  assert(uri.fragment == 'frag');
  assert(uri.origin == 'http://example.org:8080');
}</screen>

      <para>See the <ulink url="http://api.dartlang.org/uri/Uri.html">Uri API
      docs</ulink> for more URI components that you can get.</para>
    </sect2>

    <sect2 id="ch03-uri-building">
      <title>Building URIs</title>

      <para>You can build up a URI from individual parts using the
      <literal>Uri.fromComponents()</literal> <phrase role="keep-together"
      security="">constructor</phrase>:</para>

      <programlisting role="keep-together"><remark>lang-dart
</remark>import 'dart:uri';

main() {
  var uri = new Uri.fromComponents(scheme: 'http', domain: 'example.org', 
                     path: '/foo/bar', fragment: 'frag');
  assert(uri.toString() == 'http://example.org/foo/bar#frag');
}</programlisting>
    </sect2>
  </sect1>

  <sect1 id="ch03-utf">
    <title>dart:utf - Strings and Unicode</title>

    <para>The UTF library helps bridge the gap between strings and
    UTF-8/UTF-16/UTF-32 encodings.</para>

    <para>This library works in both web apps and command-line apps. To use
    it, import <literal moreinfo="none">dart:utf</literal>.</para>

    <sect2 id="ch03-utf-decode-utf8">
      <title>Decoding UTF-8 Characters</title>

      <para>Use <literal>decodeUtf8()</literal> to decode UTF8-encoded bytes
      to a Dart string:</para>

      <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:utf';

main() {
  var string = decodeUtf8([0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9,
                           0x72, 0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3,
                           0xae, 0xc3, 0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4,
                           0xbc, 0xc3, 0xae, 0xc5, 0xbe, 0xc3, 0xa5, 0xc5,
                           0xa3, 0xc3, 0xae, 0xe1, 0xbb, 0x9d, 0xc3, 0xb1]);
  print(string); // 'Îñţérñåţîöñåļîžåţîờñ'
}</screen>
    </sect2>

    <sect2 id="ch03-utf-encode-utf8">
      <title>Encoding Strings to UTF-8 Bytes</title>

      <para>Use <literal>encodeUtf8()</literal> to encode a Dart string as a
      list of UTF8-encoded bytes:</para>

      <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:utf';

main() {
  List&lt;int&gt; expected = [0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9, 0x72,
                        0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3, 0xae, 0xc3,
                        0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4, 0xbc, 0xc3, 0xae,
                        0xc5, 0xbe, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3, 0xae, 0xe1,
                        0xbb, 0x9d, 0xc3, 0xb1];

  List&lt;int&gt; encoded = encodeUtf8('Îñţérñåţîöñåļîžåţîờñ');

  assert(() {
    if (encoded.length != expected.length) return false;
    for (int i = 0; i &lt; encoded.length; i++) {
      if (encoded[i] != expected[i]) return false;
    }
    return true;
  });
}</screen>
    </sect2>

    <sect2 id="ch03-utf-other">
      <title>Other Functionality</title>

      <para>The UTF library can decode and encode UTF-16 and UTF-32 bytes. The
      library can also convert directly to and from Unicode code points and
      UTF8-encoded bytes. For details, see the <ulink
      url="http://api.dartlang.org/utf.html">API docs for the UTF
      library.</ulink></para>
    </sect2>
  </sect1>

  <sect1 id="ch03-crypto">
    <title>dart:crypto - Hash Codes and More</title>

    <para>The <ulink url="http://api.dartlang.org/crypto.html">Dart crypto
    library</ulink> contains functions useful for cryptographic applications,
    such as creating cryptographic hashes and generating hash-based message
    authentication codes.</para>

    <para>The crypto library works in both web apps and command-line apps. To
    use the crypto library, import <literal
    moreinfo="none">dart:crypto</literal>.</para>

    <sect2 id="ch03-crypto-hash">
      <title>Generating Cryptographic Hashes</title>

      <para>With the crypto library, you can use <ulink
      url="http://api.dartlang.org/crypto/SHA256.html">SHA256,</ulink> <ulink
      url="http://api.dartlang.org/crypto/SHA1.html">SHA1,</ulink> or <ulink
      url="http://api.dartlang.org/crypto/MD5.html">MD5</ulink> objects to
      generate hashes (also known as <emphasis>digests</emphasis> or
      <emphasis>message digests</emphasis>). We recommend using SHA256, but we
      have included SHA1 and MD5 for compatibility with older systems. All
      these <phrase role="keep-together">types implement</phrase> <ulink
      url="http://api.dartlang.org/crypto/Hash.html">Hash,</ulink> which
      defines the Dart interface for <ulink
      url="http://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic
      hash <phrase role="keep-together">functions</phrase>.</ulink></para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/sha256.dart
</remark>import 'dart:crypto';

main() {
  var sha256 = new SHA256();
  sha256.add('message'.codeUnits);
  var hexString = CryptoUtils.bytesToHex(sha256.close());
  assert(hexString ==
      'ab530a13e45914982b79f9b7e3fba994cfd1f3fb22f71cea1afbf02b460c6d1d');
}</screen>
    </sect2>

    <sect2 id="ch03-crypto-authentication">
      <title>Generating Message Authentication Codes</title>

      <para>Use a hash-based message authentication code (<ulink
      url="http://en.wikipedia.org/wiki/HMAC">HMAC</ulink>) to combine a
      cryptographic hash function with a secret key:</para>

      <screen format="linespecific"><remark>lang-dart
</remark><remark>ch03/hmac.dart
</remark>import 'dart:crypto';
main() {
  var hmac = new HMAC(new SHA256(), 'secretkey'.codeUnits);
  hmac.add('message'.codeUnits);
  var hmacHex = CryptoUtils.bytesToHex(hmac.close());
  assert(hmacHex ==
      '5c3e2f56de9411068f675ef32ffa12735210b9cbfee2ba521367a3955334a343');
}</screen>
    </sect2>

    <sect2 id="ch03-crypto-base64">
      <title>Generating Base64 Strings</title>

      <para>You can represent binary data as a character string by using the
      <ulink url="http://en.wikipedia.org/wiki/Base64">Base64</ulink> encoding
      scheme. Use the <literal>CryptoUtils.bytesToBase64()</literal> utility
      method to convert a list of bytes into a Base64-encoded string:</para>

      <screen format="linespecific"><remark>lang-dart
</remark>import 'dart:crypto';
import 'dart:io';

main() {
  var file = new File('icon.ico');
  var bytes = file.readAsBytesSync();
  var base64 = CryptoUtils.bytesToBase64(bytes);
  assert(base64 ==
    'iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38G'
    'IAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==');
}</screen>
    </sect2>
  </sect1>

  <sect1 id="ch03-summary">
    <title>Summary</title>

    <para>This chapter introduced you to the most commonly used functionality
    in many of Dart’s built-in libraries. It didn’t cover all the built-in
    libraries, however. Other libraries you might want to look into include
    <ulink
    url="http://api.dartlang.org/dart_collection.html">dart:collection,</ulink>
    <ulink
    url="http://api.dartlang.org/dart_mirrors.html">dart:mirrors,</ulink>
    <ulink url="http://api.dartlang.org/logging.html">logging,</ulink> <ulink
    url="http://api.dartlang.org/mock.html">mock,</ulink> and <ulink
    url="http://api.dartlang.org/unittest.html" wordsize=""><phrase
    role="keep-together">unittest</phrase>.</ulink> You can use the pub tool,
    discussed in the next chapter, to install additional Dart <phrase
    role="keep-together">libraries</phrase>.</para>
  </sect1>
</chapter>
